<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM参数分类]]></title>
    <url>%2Fblog%2F2019%2F08%2F07%2Fjvm%E5%8F%82%E6%95%B0%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[JVM参数的分类常用的JVM参数可以大致的分为三类，下边简单的将JVM的参数做一个分类，作为一个JVM参数的简单总结。 JVM标准参数JVM的标准参数是指的在各个JDK版本中都比较稳定的，不会变动的参数，一般是针对jdk全局的参数。 比如 -help -server -client -version -showversion -cp -classpath 这种参数称之为标准参数。 JVM非标准化参数JVM非标准化参数指的是在各个jdk版本中会有略微变化的参数，这里可以分为 -X参数 和 -XX参数 -X参数比如-X参数有： -Xint : 解释执行 -Xcomp ：第一次使用就编译成本地代码（java不是严格的解释性或者编译性执行的语言） -Xmixed : 上面两种混合模式，有编译器自己去优化选择。 可以看到当前电脑上jdk的version中可以显示这个参数的值： 这里是mix模式，我们可以通过命令java -Xint -version来将mode调整为int模式： -XX参数-XX参数使我们平常使用最多的JVM参数，主要用于调优和Debug。 常见的-XX参数有 Boolean类型 格式：-XX:[+/-]&lt;name&gt; 表示启动或者禁用了name参数 比如：-XX:+UseConcMarkSweepGC表示启用了CMS垃圾回收器 ​ -XX:+UseG1GC 表示启用了G1垃圾回收器 非Boolean(Key-Value类型) 格式：-XX:&lt;name&gt;=&lt;value&gt; 表示name参数的值是value 比如：-XX:MaxGCPauseMills=500表示GC最大的停顿时间是500 ​ -XX:GCTimeRatio=19 -XX参数常见的参数还有一种缩写模式（虽然是-X开头，但是其实是-XX参数） 比如： -Xms 等价于-XX:InitialHeapSize 表示初始化堆大小 -Xmx 等价于-XX:MaxHeapSize 表示最大堆的大小 -Xss 等价于 -XX:ThreadStackSize 线程堆栈的大小 可以使用 jinfo -falg &lt;参数名称&gt; 命令行工具去查看当前java进程的JVM参数。 比如： jinfo -flag MaxHeapSize pid 之后会介绍命令行工具去查看对应的JVM参数。]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM参数分类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用@DependsOn解决一个spring启动问题]]></title>
    <url>%2Fblog%2F2019%2F08%2F04%2F%E4%BD%BF%E7%94%A8-DependsOn%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AAspring%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言最近遇到了一个启动失败的问题，原因是在bean初始化完成之后的钩子方法中使用获取容器中bean的工具类，(对应工具类之前的一篇博客 获取springbean)）。 分析这里具体的场景是我想实现一个bean在钩子方法中往一个策略map中注册自己作为一个策略使用，但是在启动的时候报错: 第33行代码如下： 123public static &lt;T&gt; T getBean(@NotNull Class&lt;T&gt; tClass) &#123; return context.getBean(tClass); &#125; 可以看到可能为空的是context，这个是通过在项目中启动时注入到ApplicationContextUtil中的静态变量context，很明显是在当前这个bean启动的时候，其钩子方法去调用这个变量还没实现context的注入。 1234@Override public void afterPropertiesSet() throws Exception &#123; // 策略工厂中注册 自身 的代码 &#125; 解决这里主要是一个场景，其实在bean启动的时候是依赖ApplicationContextUtil这个bean的，但是因为getBean方法都static方法，在平常业务代码中调用都是容器启动完毕的时候，所以没有问题，但是这里是想实现在bean初始化时自动通过钩子往一个map工厂中注册bean实例，且该bean没有显示的@Resource依赖ApplicationContextUtil，所以在注册的时候applicationContextutil这个bean还没初始化好，这里在这些具体策略的类上加了@DependsOn(“applicationContextUtil”) 12345@Service@Slf4j@DependsOn(value = "applicationContextUtil")public class AStrategy extends AbstractStrategy &#123;&#125; 这表示这个bean的初始化是依赖 applicationContextUtil 这个bean初始化完成之后(也就是静态变量上下文被注入)才去初始化的，这样启动就不会报NPE了。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>DependsOn注解</tag>
        <tag>spring启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道题的思考]]></title>
    <url>%2Fblog%2F2019%2F07%2F22%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE%E4%B8%80%E9%81%93%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[题目在小马哥的每日一问中看到了一道这个题：输出什么？。当时看错了在static块中的代码，就毫不意外的答错了= =，这个题其实没有看起来那么简单，这里去记录下这个题。小马哥这个每日一题的系列有很多比较”坑”的题，一般第一遍都比较难答对，推荐每天没事的时候可以去思否上看看这个题，也算拾遗一些基础~ 再来看看这个问题的代码： 123456789101112131415161718public class Lazy &#123; private static boolean initialized = false; static &#123; Thread t = new Thread(() -&gt; initialized = true); t.start(); try &#123; t.join(); &#125; catch (InterruptedException e) &#123; throw new AssertionError(e); &#125; &#125; public static void main(String[] args) &#123; System.out.println(initialized); &#125;&#125; 这个题问的是最后输出的什么。一开始很想当然的就去想输出什么，但是最后在ide中试了下运行，发现启动就卡在了那里_(:з」∠)… 后面就去用jstack看了下线程的情况： 1234567891011121314151617182019-08-03 20:23:45Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.171-b11 mixed mode):"Thread-0" #10 prio=5 os_prio=31 tid=0x00007fece71eb800 nid=0x3d03 in Object.wait() [0x0000700005bbb000] java.lang.Thread.State: RUNNABLE at 函数式设计.设计.Lazy$$Lambda$1/495053715.run(Unknown Source) at java.lang.Thread.run(Thread.java:748)"main" #1 prio=5 os_prio=31 tid=0x00007fece6803800 nid=0x1703 in Object.wait() [0x0000700004c8e000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000007956ffb30&gt; (a java.lang.Thread) at java.lang.Thread.join(Thread.java:1252) - locked &lt;0x00000007956ffb30&gt; (a java.lang.Thread) at java.lang.Thread.join(Thread.java:1326) at 函数式设计.设计.Lazy.&lt;clinit&gt;(Lazy.java:11)JNI global references: 320 发现Thread-0是Runnable状态的，但是是in object.wait() 这里还是卡住了没有执行。 思考这个题里有几个点： （1）static块也是main线程去加载的 （2）匿名内置类和lambda是有区别的 这里去简单说明下，如果在线程中用的是new Runnable的匿名内置类的方式： 1234567891011121314151617181920static &#123; println("static模块加载了"); Thread t = new Thread( // new Runnable 匿名内置类是 通过 Lazy$1.class来实现的 new Runnable() &#123; @Override public void run() &#123; &#125; &#125; ); t.start(); try &#123; t.join(); &#125; catch (InterruptedException e) &#123; throw new AssertionError(e); &#125; &#125; 也就是在看编译生成的字节码目录中会多一个Lazy$1.class文件: 并且在反编译Lazy中看到static块中，依赖这个Lazy$1.class的init方法。 而如果是使用的是像题目中的lambda表达式方式，可以看到字节码文件中并没有Lazy$1.class，而是在反编译class文件中的字节码中多了invokeDynamic指令来实现的lambda表达式： 如果是匿名内之类的方式我们先看如果是换成Runnable匿名内置类方式，而实现的run方法是个空方法体，即代码为： 123456789101112131415161718192021222324252627282930313233private static boolean initialized = false; // static也是由main线程去初始化的 static &#123; println("static模块加载了"); Thread t = new Thread( // new Runnable 匿名内置类是 通过 Lazy$1.class来实现的 new Runnable() &#123; @Override public void run() &#123; System.out.println("匿名内置类执行"); &#125; &#125; ); t.start(); try &#123; t.join(); &#125; catch (InterruptedException e) &#123; throw new AssertionError(e); &#125; &#125; public static void main(String[] args) &#123; println("main线程执行了"); System.out.println(initialized); &#125; private static void println(Object o) &#123; System.out.printf("线程[%s]- %s\n", Thread.currentThread().getName(), o); &#125; 这时启动并不会hang住；将run方法中加入了对static变量initialized的修改或者调用private static方法println，即代码为： 1234567 @Override public void run() &#123; System.out.println("匿名内置类执行"); // 调用 static变量赋值或者static方法就会发生类似于死锁的现象 因为静态变量算这个类的一部分 initialized = true;// println("static方法 打印线程名称执行"); &#125; 再次启动，会发现也hang住出现死锁现象。 其实从上面三点就可以分析出，因为在static模块执行时(Lazy类是不完全初始化的)，这时Runnable类也随之初始化，如果在Runnable类(也就是Lazy$1.class)初始化的时候，还依赖了Lazy的静态变量或者静态方法，那么就会产生字节码直接的循环依赖。 可以在下图中看到字节码中invokestatic指令代表依赖了Lazy的静态内容初始化完成： 再看回这道题如果是lambda表达式，即使run方法中是空实现(即不在run方法中引用static变量或者static方法)，启动也会hang住，这说明lambda来初始化线程并不受是否引用了static内容影响。 这里是因为 invokedDynamic指令是Lazy字节码的一部分，不需要因为引用static方法或者变量来执行，它需要等待Lazy类初始化的完成，而本身初始化完成又依赖invokedDynamaic指令的执行，同时执行的是字节码方法符为run:()Ljava/lang/Runnable，是执行自己的run方法，所以在字节码上也是一个循环依赖。(类加载器loadClass是同步的)。 这里注意下：这里不是只要用了invokeDynamic指令就会发生这个问题，比如方法引用也是通过invokeDynamic指令实现的如果在run方法中使用的是代码： 123456789101112131415static &#123; println("static模块加载了"); Thread t = new Thread( // 方法引用 System.out::println ); t.start(); try &#123; t.join(); &#125; catch (InterruptedException e) &#123; throw new AssertionError(e); &#125; &#125; 但是启动就不会有问题，因为这个等待的是java.io.PrintStream这和类初始化，而这个类初始化是BootStrap类加载器初始化的，早于Lazy类初始化加载，所以能正常运行。 也就是说，在static代码块中： 当使用匿名内置类的时候，注意不要依赖外部类的静态变量或者方法 当使用lambda表达式或者方法引用，注意类的加载的先后顺序，如果依赖不当，会造成启动死锁的情况。]]></content>
      <categories>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java枚举拾遗]]></title>
    <url>%2Fblog%2F2019%2F06%2F12%2Fjava%E6%9E%9A%E4%B8%BE%E6%8B%BE%E9%81%97%2F</url>
    <content type="text"><![CDATA[前言java枚举是在开发过程中用的最多的类，这里对java之前的枚举常量类和枚举做了一个分析，并且对枚举相关知识拾遗。 枚举类在出现枚举之前，通常是一个final类去表示”可枚举”这个概念，比如下面这个列举数字的枚举类 1234567891011121314151617181920212223242526/** * 模拟枚举类 (枚举类：在enum出现之前的表达 可枚举的含义的类) * 通常 private 构造函数 * final class * private static final 本类型 成员 * */final class EnumClass&#123; public static final EnumClass ONE = new EnumClass(1); public static final EnumClass TWO = new EnumClass(2); public static final EnumClass THREE = new EnumClass(3); public static final EnumClass FOUR = new EnumClass(4); @Getter @Setter private int value; private EnumClass(int value) &#123; this.value = value; &#125; public void print() &#123; System.out.println(this.toString()); &#125;&#125; 可以看到枚举类的特点： 成员用常量来表示，并且类型为当前类型(当前类型) 常被设置为final类 非public构造器(自己内部来创建实例) 这样有些缺点，比如： 枚举的输出打印的时候要怎么做？每个成员是第几个定义的？要想达到这些操作就必须要写一些方法，而每个枚举类去这样写这样的方法是比较蛋疼的，因为他不具有枚举的values方法。 枚举这里写出对应的java枚举 12345678910111213enum CountingEnum &#123; ONE(1), TWO(2), THREE(3), FOUR(4) ; @Getter private int value; /** private */ CountingEnum (int value) &#123; this.value = value; &#125;&#125; 这里如果想要输出对应的名字和顺序，那么就十分方便了。 1234// 输出 枚举 中的名字、位置、输出所有枚举 Arrays.stream(CountingEnum.values()).forEach(e -&gt; &#123; System.out.println("输出枚举中的顺序: " + e.ordinal() + "名字：" + e.name() + "value：" + e.getValue()); &#125;); 可以看到输出： 这是因为java所有的枚举都是继承Enum抽象类的，而valueOf()方法、ordinal()方法、name()方法都是定义在其中的，可以看下Eunm抽象类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; private final String name; public final String name() &#123; return name; &#125; private final int ordinal; public final int ordinal() &#123; return ordinal; &#125; protected Enum(String name, int ordinal) &#123; this.name = name; this.ordinal = ordinal; &#125; public String toString() &#123; return name; &#125; public final boolean equals(Object other) &#123; return this==other; &#125; public final int hashCode() &#123; return super.hashCode(); &#125; protected final Object clone() throws CloneNotSupportedException &#123; throw new CloneNotSupportedException(); &#125; public final int compareTo(E o) &#123; Enum&lt;?&gt; other = (Enum&lt;?&gt;)o; Enum&lt;E&gt; self = this; if (self.getClass() != other.getClass() &amp;&amp; // optimization self.getDeclaringClass() != other.getDeclaringClass()) throw new ClassCastException(); return self.ordinal - other.ordinal; &#125; @SuppressWarnings("unchecked") public final Class&lt;E&gt; getDeclaringClass() &#123; Class&lt;?&gt; clazz = getClass(); Class&lt;?&gt; zuper = clazz.getSuperclass(); return (zuper == Enum.class) ? (Class&lt;E&gt;)clazz : (Class&lt;E&gt;)zuper; &#125; public static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) &#123; T result = enumType.enumConstantDirectory().get(name); if (result != null) return result; if (name == null) throw new NullPointerException("Name is null"); throw new IllegalArgumentException( "No enum constant " + enumType.getCanonicalName() + "." + name); &#125; /** * enum classes cannot have finalize methods. */ protected final void finalize() &#123; &#125; /** * prevent default deserialization */ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; throw new InvalidObjectException("can't deserialize enum"); &#125; private void readObjectNoData() throws ObjectStreamException &#123; throw new InvalidObjectException("can't deserialize enum"); &#125;&#125; 仔细看也许你会有两个疑问： 没看到显示的定义CountingEnum时继承Enum类的？ values方法也没有看到在父类中定义？ 对这两个疑问我们可以去看这个类对应的字节码： 可以看到： enum其实也是final class， 虽然没有显示继承，但是其实是继承了Enum&lt;T&gt;类的，所以可以访问到对应的name，ordinal字段，这个设计让我们输出枚举一些信息的时候很便捷。也提供了valueOf方法，也可以在动态判断枚举的时候使用。 在来看下边的字节码： 可以看到是有values方法，其实这个是jvm通过字节码提升的方式去为枚举做的优化。所以使用枚举可以快速遍历并且一些输出之类的操作。 可以总结下枚举的特点： 枚举其实就是final class，并且继承java.lang.Enum抽象类。 枚举可以实现接口。 枚举不能显示的继承和被继承 留个坑：既然是final class，那么枚举里可以定义抽象方法吗？ 枚举中抽象方法的设计我们在看基础语法的时候，总是说final 和 abstract是互斥的，所以想当然的认为枚举中不能定义抽象方法，但结论其实是可以的。 我们先看一个枚举来实现加减操作的例子： 123456789101112131415enum Opration &#123; PLUS, DIVIDE ; public double apply(double x, double y) &#123; switch (this) &#123; case PLUS: return x + y; case DIVIDE: return x - y; &#125; throw new AssertionError("unknown"); &#125;&#125; 这个实现其实是通过在枚举中加入了非枚举含义的方法和域来实现的操作的一个类型枚举。但是有个问题，当拓展新的操作符时，需要破坏switch中的逻辑，这个不太符合开闭原则，这时候就可以通过把apply作为抽象方法，使得拓展时只需要实现符合自己的抽象逻辑。 123456789101112131415161718192021222324252627/** * 通过抽象方法， 来实现加入新的操作的时候 能符合开闭原则，只关心自己操作符抽象的实现 */enum OperationOptimize &#123; PLUS("+")&#123; @Override public int apply(int x, int y) &#123; return x + y; &#125; &#125;, DIVIDE("-") &#123; @Override public int apply(int x, int y) &#123; return x - y; &#125; &#125; ; @Getter private String str; private OperationOptimize(String str) &#123; this.str = str; &#125; // 抽象方法 public abstract int apply(int x, int y);&#125; 所以枚举是可以定义抽象方法的。 jdk中其实也有对应的例子，可以看下TimeUnit这个时间单位枚举，枚举类型都是通过实现抽象方法(其实是返回异常的普通方法，思想是一样的)来实现不同时间单位的转化。 彩蛋如何给上边的枚举类实现一个values方法？ 因为需要遍历所有的字段，所以很自然的想到了反射去实现。这里需要注意，因为枚举类定义的枚举都是public static final，而作为val变量是int的一个修饰符，需要将除了枚举外的val变量排除~ 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950final class EnumClass &#123; public static final EnumClass ONE = new EnumClass(1); public static final EnumClass TWO = new EnumClass(2); public static final EnumClass THREE = new EnumClass(3); public static final EnumClass FOUR = new EnumClass(4); @Getter @Setter private int value; private EnumClass(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return "EnumClass&#123;" + "value=" + value + '&#125;'; &#125; public void print() &#123; System.out.println(this.toString()); &#125; /** * 为枚举类实现一个values方法 */ public static EnumClass[] values() &#123; // 获取枚举类中所有字段 return Stream.of(EnumClass.class.getDeclaredFields()) // 过滤出 public static final的 .filter(field -&gt; &#123; // 修饰符 int modifiers = field.getModifiers(); return Modifier.isPublic(modifiers) &amp;&amp; Modifier.isStatic(modifiers) &amp;&amp; Modifier.isFinal(modifiers); &#125;) // 取出对应的字段值 .map(field -&gt; &#123; try &#123; return field.get(null); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125;).toArray(EnumClass[]::new); &#125;&#125;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis命令拾遗(哈希表)]]></title>
    <url>%2Fblog%2F2019%2F05%2F21%2Fredis%E5%91%BD%E4%BB%A4%E6%8B%BE%E9%81%97-%E5%93%88%E5%B8%8C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[redis哈希表操作命令redis也支持对hash表结构进行操作，体现在下边几个命令。 hset hash field value这个命令]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis哈希表命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis命令拾遗(字符串操作)]]></title>
    <url>%2Fblog%2F2019%2F05%2F19%2Fredis%E5%91%BD%E4%BB%A4%E6%8B%BE%E9%81%97(%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C)%2F</url>
    <content type="text"><![CDATA[前言前一段时间一直在忙，拉下了一些知识的学习，现在努力追赶修补中。= = 当然也有一些新的知识的学习，但其实更多的是关于一些知识的拾遗。之前在工作当中发现对redis命令掌握的还不是很完善，所以想花比较少的碎片时间去写一下redis常用命令的拾遗。 redis命令对这些命令的拾遗记录是在网站：http://redisdoc.com上进行学习的，很简单明了，推荐给大家进行学习拾遗。 这里只是把日常会被忽略或者遗忘的点进行一下梳理，并不是每个知识点的一个总结。 字符串操作####set命令 set可以通过一系列参数进行修改： ex seconds ：将键的过期时间设置为seconds秒，具体的命令是set key value EX seconds。等同于执行setex key second value。 px milliseconds：和ex一样，只不过单位是毫秒，具体的命令是 set key value PX milliseconds。等同于执行psetex key milliseconds value。 nx / xx： set key value nx等价于 setnx key value；set key value xx是当键存在才设置值，没有setxx这个吗命令，这两个设置值失败的时候，set命令会返回nil，而直接使用setnx命令，则返回的是0和1。 setex命令setex命令效果等价于执行下边两个命令： 12set key valueexpire key seconds 但是不同的是，setex是一个原子的操作，它是在同一时间完成设置值和过期时间的操作，经常用在存储缓存时候。 setex设置成功时候 返回ok。 同样psetex只是单位是毫秒而已。 get命令get命令不用多说，但是注意get命令只是用在字符串操作，如果key对应的值不是字符串类型，那么返回一个错误。 getset命令此命令的作用是：将key设置为value，并且返回key在被设置之前的值。如果key之前不存在，则返回nil。当键key存在但不是字符串时，会报错。 strlen命令返回字符串key的长度，当key不是字符串时，返回一个错误。如果key不存在，返回0。 append命令append命令：如果已经存在key并且它的值是一个字符串，append命令将value追加到key对应值的末尾。如果key不存在，append命令会像执行set key value一样将值设置为对应的key的值。 append命令的返回值是值字符串的长度。 注意append的时间复杂度是平摊o(1) setrange key offset value指从偏移量offset开始，用value参数覆写value值。这个命令会确保字符串足够长以便于设置value到对应的偏移量。比如字符串只有5个字符长，但设置的offset是10，那么会在原来字符串值到偏移量之间设置零字节(“\x00”)进行填充。 这个命令的返回值是被修改之后字符串值的长度 getrange key start end这个命令指的是返回键key对应的字符串值的指定部分，字符串的截取范围由start end两个参数决定(包括start和end在内)。start和end支持负数偏移量，-1代表最后一个字符，-2代表倒数第二个字符。但是注意只能按照字符串顺序获取，不能倒序获取(比如 getrange key -1 -3) incr keyincr虽然是自增的含义命令，但其实是一个属于字符串的操作，redis并未提供一个专用的整数类型，所以键key存储的值在执行incr命令的时候会被翻译解释为十进制64位有符号整数。 如果incr操作的key值对应不存在，那么先会初始化为0，然后再执行incr命令。 如果key值不能被解释为数字，那么会返回一个错误。 incrby key increment和incr一样的含义，只不过有递增量为increment。同样的递减是有对应的decr key和decrby key decrement。 incrbyfloat key increment这个就是针对浮点数的增加计算。注意incrbyfloat命令计算的结果最多只保留小数点后面17位。 mset key value [key value …]同时为多个键设置值，这个命令是一个原子操作，所有给定键会在同一时间内被设置，并且具有set的特性，会覆盖key对应原来的值。如果仅是在不存在的情况下设置值，可以用msetnx，msetnx也是一个原子操作，如果多个key中有一个key没有设置上，那么所有的key都不会设置对应的值。]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo基础（五）——dubbo接口的特性设置]]></title>
    <url>%2Fblog%2F2019%2F03%2F31%2Fdubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94dubbo%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E6%80%A7%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[dubbo的一些配置之前的文章中写了dubbo的初步使用和dubbo和springboot的使用整合，这里来总结下dubbo框架暴露接口常用的配置项。 启动时检查dubbo提供了在服务启动时的一些检查机制，这个机制包括consumer端对服务提供者的检查、dubbo对注册中心的检查。可以看下官方文档中dubbo:reference标签中关于check属性的配置。 可以看到是默认在启动时检查服务提供者是否存在，不可用时会抛出异常，组织spring初始化。 我们这里可以将之前demo中的userService服务的消费者上配置check=true(默认就是true)，来看看在不启动服务提供者时的消费者控制台的报错： 是经典的No Provider错误。这里官方文档也对这个配置做了说明： 如果在配置文件中设置了dubbo.reference.check=false，则是强制改变所有reference的check值，就算配置中部分接口有声明，也会被覆盖。 同时，也可以在配置文件中设置dubbo.consumer.check=false，这个是设置所有的reference的check属性默认值，当配置文件中有对单个reference的check的显式设置，会被覆盖掉 这里也可以去看下对注册中心不存在时的错误： 如果我们在reference标签和register标签中显示配置check=”false”，这些错误只有在调用时才会报错。 超时在dubbo的service和reference标签中都有timeout设置，service标签中timeout是1000ms，代表远程服务调用时间；而reference标签中的timeout设置默认值是继承自dubbo:consumer标签中的默认值，也是1000ms。在前几篇dubbo配置中有提到，timeout的配置遵守一个规则： 更精准的优先。方法级别配置会覆盖接口级别的配置，接口级别的配置会覆盖全局的provider、consumer配置。 如果精准级别相同，消费方优先。当配置的颗粒度是相同的，如果消费方设置了超时属性，会覆盖服务提供方超时属性的配置。 比如这里设置服务提供者的超时是5000ms： 123&lt;dubbo:service interface="service.user.UserService" ref="userService" timeout="5000" version="0.0.1" stub="service.user.UserServiceStub"&gt;&lt;/dubbo:service&gt; 而在消费者配置超时是2000ms： 1&lt;dubbo:reference id="userService" interface="service.user.UserService" version="0.0.1" timeout="2000"/&gt; 在服务提供者加入一个3000ms的sleep，这里按照配置的优先级会是消费者的2000ms生效。这里会报dubbo接口调用超时的错误：(错误信息中接口调用花费了2004ms，超时生效的是2000ms配置，报错是waiting server-side response timeout) 重试次数在dubbo:service和dubbo:reference标签中可以设置retries属性来设置接口调用失败时的重试次数，这里重试此时指的是第一次调用之后的重试次数，并且这里的重试会遵守负载均衡的策略。 service标签中的重试次数默认是2，而reference标签的默认重试次数继承consumer标签的默认次数也是2。这里去简单模拟下有三个服务提给者，调用失败的场景是依靠上边的超时设置，重试次数也尊属消费者优先的规则。 在不同的端口暴露userService服务，每个服务会打印第几个服务，并且有对应的睡眠时间模拟调用： 端口是20880，睡眠时间是5000ms 12345&lt;dubbo:protocol name="dubbo" port="20880" /&gt;&lt;dubbo:service interface="service.user.UserService" ref="userService" version="0.0.1" stub="service.user.UserServiceStub"&gt;&lt;/dubbo:service&gt; 端口是20881，睡眠时间是5000ms 12345&lt;dubbo:protocol name="dubbo" port="20881" /&gt;&lt;dubbo:service interface="service.user.UserService" ref="userService" version="0.0.1" stub="service.user.UserServiceStub"&gt;&lt;/dubbo:service&gt; 端口是20882，睡眠时间是2000ms 12345&lt;dubbo:protocol name="dubbo" port="20882" /&gt;&lt;dubbo:service interface="service.user.UserService" ref="userService" version="0.0.1" stub="service.user.UserServiceStub"&gt;&lt;/dubbo:service&gt; 而在消费者端配置超时时间是3000ms，所以只有端口是20882提供的服务可以不会因为超时调用失败。 消费端的配置： 1&lt;dubbo:reference id="userService" interface="service.user.UserService" version="0.0.1" timeout="3000"/&gt; 服务启动之后，发起调用可以看到consumer端的日志： 对20880端口暴露的服务调用超时之后，因为默认的负载均衡策略是加权随机调用，这里重试调用了第三个服务接口调用成功。 这里要知道重试应该配置在幂等的接口上，比如查询、更新等，因为会进行重试进行请求。 多版本功能同一个服务要升级时可能出现服务不稳定的情况，可以使用版本号进行过度，不同的版本号之间是隔离的。 在service标签上配置的version属性就是服务提供者的版本；而reference标签上的version则代表引用服务的版本。 我们也在上边使用了0.0.1版本，而和spring boot整合的dubbo接口版本是boot-1.0.0。 如果配置version=”*” 如下，则表示的是随机引用版本。 &lt;dubbo:reference id=&quot;barService&quot; interface=&quot;com.foo.BarService&quot; version=&quot;*&quot; /&gt; 负载均衡dubbo框架对集群环境下提供了多种负载均衡机制： 基于权重的随机负载均衡 Random LoadBalance (dubbo的默认的负载均衡策略)。 基于权重的轮询负载均衡机制。 最小活跃数负载均衡机制。 一致性hash负载均衡(注意这里是一致性hash，因为集群中的服务节点可以增加、减少)。]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo接口属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo基础（四）——dubbo的配置加载]]></title>
    <url>%2Fblog%2F2019%2F03%2F20%2Fdubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94dubbo%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[dubbo的配置在之前的文章中配置了spring boot和dubbo框架的使用（传送门：springboot使用dubbo框架），看到了把dubbo相关的配置配置在了配置文件中。这里官方文档中也去讲解了对应的dubbo配置的加载。 dubbo的配置加载流程首先要知道dubbo的配置是在应用启动阶段，并且这里的配置包括应用配置、注册中心配置、服务配置等。 dubbo的配置来源 Jvm System Properties，-D参数 Externalized Coniguration， 外部化配置，这里在文档中提到的有zk、apollo ServiceConfig、ReferenceConfig等编程接口采集的配置 项目本地的配置文件 dubbo.properties 除了外部化配置，dubbo的配置读取在总体上遵循了以下几个原则： dubbo支持了多层级的配置，并且按预定优先级自动实现配置间的覆盖，最终所有配置汇总到数据总线URL后，驱动后续的服务暴露、引用等流程。 ApplicationConfig、ServiceConfig、ReferenceConfig也可以理解为配置来源的一种，是直接面向用户编程的配置采集方式 配置格式以Properties为主，在配置上支持path-based的命名规范。 dubbo配置的覆盖策略dubbo的配置覆盖策略如下图： 这里看到dubbo预先设置的配置覆盖加载顺序是jvm设置的启动参数 —&gt; 外部配置 —&gt; spring的xml或者api配置 —&gt; 项目中的本地文件。 这里以上一篇中的spring boot和dubbo整合的demo来测试这个覆盖顺序。这里外部的配置先不做演示，只去比较启动参数、spring配置、本地dubbo.properties配置三个覆盖顺序。 我们以dubbo.protocol.port这个配置作为示例： jvm启动参数 首先配置启动时的vm参数： 启动之后，可以看到此时服务在dubbo-admin上显示的端口为我们在启动参数中设置的20881。(配置文件中配置的是20880，这里优先读取的是启动参数中的配置) spring配置 这里因为使用的是spring boot，所以在application.properties中配置即可。 这里启动provider项目，可以看到之前的接口下线，然后暴露服务的端口变为了20880。 本地的dubbo.properties配置 在本地建立一个dubbo.properties文件，这里写成暴露服务的端口是20882。(这里要主要将spring配置中配置注释掉。) 重新启动provider，可以看到对应的dubbo接口暴露为了20882。 以xml配置说明不同粒度的覆盖和优先级由下图可以知道这些配置标签分为provider侧、consumer侧、应用共享的配置(这里包括application、注册中心、monitor的配置)、还有一些子配置(方法、参数级别的配置)不同的粒度。 这些不同的粒度的配置也有对应的覆盖关系，以timeout为例，其他retries，loadbalance，actives等类似，都遵守粒度之间的覆盖规则： 方法级别优先，接口级别次之，全局配置再次之。 如果级别一样，则消费方优先，提供方次之。 其中，服务提供方配置，通过 URL 经由注册中心传递给消费方。具体如下图所示： 这里就timeout这个超时参数，建议由服务提供方设置超时，因为一个方法需要执行多长时间，服务提供方更清楚，如果一个消费方同时引用多个服务，就不需要关心每个服务的超时设置。 这里的一个小tips： 引用缺省是延迟初始化的，只有引用被注入到其它 Bean，或被 getBean() 获取，才会初始化。如果需要饥饿加载，即没有人引用也立即生成动态代理，可以配置：&lt;dubbo:reference ... init=&quot;true&quot; /&gt;]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo基础（三）——spring boot调用dubbo]]></title>
    <url>%2Fblog%2F2019%2F03%2F20%2Fdubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94spring-boot%E8%B0%83%E7%94%A8dubbo%2F</url>
    <content type="text"><![CDATA[dubbo集成spring bootspring boot肯定是现在用的做多的开发框架，而dubbo框架是最流行的rpc框架之一，整合springboot和dubbo的使用很有必要。本篇博客还是根据上一篇中的dubbo简单demo的简单示例来整合spring boot。(上一篇传送门：dubbo-demo) 依赖因为是springboot项目，dubbo官方也提供了dubbo的starter。 123456&lt;!-- dubbo starter --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt; 这里注意下spring boot的版本和dubbo-starter的版本映射关系，这里使用的是spring boot 2.1.3版本，用的是0.2版本的dubbo依赖，而1.x版本的spring boot框架则对应0.1.x版本的dubbo starter。 这里引入了starter之后也引入了之前在上一篇中的zk客户端依赖。 这里也遇到了idea新建maven module之后的一些坑，一直没办法加载对应的类，这里提示下可以尝试查看idea的maven配置，是不是把新加入的module勾选了ignore： boot-provider这里也是去先构造对应的服务提供者，提供一个用户地址的简单查询服务。但是spring boot多采用注解驱动和避免了很多繁琐的xml配置，所以这里我们去将dubbo的全局配置配置在application.properties文件中，而关于服务的暴露也是用注解暴露。 dubbo应用配置12345678# 应用方信息dubbo.application.name=boot-dubbo-demo# 注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181# 协议名称dubbo.protocol.name=dubbo# 协议端口dubbo.protocol.port=20800 可以看到这里其实就是对应的之前普通spring项目中使用dubbo的provider.xml的标签配置。 这里要注意是在启动类上要加入@EnableDubbo注解开启spring boot对dubbo的支持。 服务的暴露这里是用的@Service注解暴露服务，其实也是对应着dubbo-provider.xml中的dubbo:service标签，这里要注意是不要引入是spring的@Service注解。可以看到这个service注解中也有dubbo:service中对应的属性，比如这里写入的version版本信息。 12345678910111213141516171819202122232425262728293031323334353637383940import com.alibaba.dubbo.config.annotation.Service;import javabean.UserAddress;import org.springframework.stereotype.Component;import service.user.UserService;import java.util.ArrayList;import java.util.List;/** * @author 夸克 * @date 2019/3/18 00:15 */@Component@Service(version = "boot-1.0.0")public class UserServiceImpl implements UserService &#123; @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; System.out.println(Thread.currentThread().getName() + " 调用到了消费者"); final UserAddress userAddress1 = new UserAddress() .setUserId(1L) .setAddressId(1L) .setAddressNo("123") .setAddressStr("庆丰大街") .setUserName("小张"); final UserAddress userAddress2 = new UserAddress() .setUserId(1L) .setAddressId(2L) .setAddressNo("456") .setAddressStr("西湖") .setUserName("小王"); return new ArrayList&lt;UserAddress&gt;()&#123;&#123; add(userAddress1); add(userAddress2); &#125;&#125;; &#125;&#125; 启动provider项目，就可以在dubbo-admin上看到注册到注册中心的服务。 boot-consumer消费者端要配置大体和服务提供者端是一样的，也是用@Refernce注解来代替对应的dubbo:refernce标签。这里也要在启动类上去加入@EnableDubbo注解。 dubbo的配置1234567# 应用方信息dubbo.application.name=boot-dubbo-demo# 注册中心地址dubbo.registry.address=zookeeper://127.0.0.1:2181# 启动端口server.port=8081 这里的端口是8081是因为provider和consumer是两个spring bootmodule 都是启动类去启动的，这里测试在一台电脑上要是不同的端口。 引用暴露的服务123456789101112131415161718192021222324@Servicepublic class OrderServiceImpl implements OrderService &#123; @Reference(version = "boot-1.0.0", timeout = 50000) private UserService userService; /** * 生成订单过程： * 调用远程接口 查询用户信息 * 将用户信息去生成订单 * @return */ @Override public List&lt;UserAddress&gt; initOrder() &#123; List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList("1"); if (null != userAddressList &amp;&amp; userAddressList.size() &gt; 0) &#123; System.out.println("调用远程接口完成"); Optional.of(userAddressList).ifPresent(System.out::println); &#125; return userAddressList; &#125;&#125; 可以看到@Reference注解中也可对应dubbo:reference标签的属性，这里设置的超时时间和对应的版本。 简单controller测试这里去写了一个简单的controller去测试spring-boot使用dubbo这个框架： 1234567891011@RestControllerpublic class TestController &#123; @Resource private OrderService orderService; @GetMapping(path = "/initOrder") public List&lt;UserAddress&gt; initOrder(@RequestParam("userId") Integer userId) &#123; return orderService.initOrder(); &#125;&#125; github地址https://github.com/zhanglijun1217/dubbo-demo]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo基础</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo基础（二）——一个简单调用demo]]></title>
    <url>%2Fblog%2F2019%2F03%2F18%2Fdubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%B0%83%E7%94%A8demo%2F</url>
    <content type="text"><![CDATA[get start在上一篇中介绍了dubbo诞生的背景和框架的特性：dubbo概念和基本概念，这里就来一个dubbo的简单使用小体验。 dubbo注册中心安装dubbo中的官方文档的快速启动使用的是multicast广播注册中心暴露服务地址，这里选择的是使用zk作为注册中心，因为zk是很多公司作为dubbo注册中心，并且zk也是dubbo官方文档中推荐使用的注册中心。 本次是使用的mac上安装的zk，安装步骤：mac下安装zk dubbo-demo建立此次是采用maven构建整个项目。整个项目中的module结构如下： 其中： common-interface是抽离出的公用接口，其实这里就是将provider中的接口和consumer中的接口抽离出来 order-service-consumer是此次设置的dubbo-consumer，模拟的是一个订单服务，里面有一个初始化订单的方法。 user-service-provider是此次设置的dubbo服务提供者，模拟的是一个用户服务，在初始化订单时肯定要查询用户服务的接口。 maven依赖此次在项目中的依赖用到了dubbo的依赖，因为使用的是zk注册中心，所以这里要引入zk的客户端依赖，这里要注意的是dubbo2.6版本之后是要引入zk的curator客户端。 dubbo依赖： 123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo 这个dubbo版本是集成了spring的 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt; zk client依赖 1234567&lt;!-- curator-framework --&gt;&lt;!-- dubbo2.6 以上版本要引入curator 的 zk客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-framework&lt;/artifactId&gt; &lt;version&gt;2.12.0&lt;/version&gt;&lt;/dependency&gt; provider由dubbo的架构图可知 provider提供的服务要先注册在注册中心上，这里就要去配置provider相关的配置。 可以看到provider要提供的接口服务： 1234public interface UserService &#123; List&lt;UserAddress&gt; getUserAddressList(String userId);&#125; 这里可以给一个简单实现： 1234567891011121314151617181920212223242526public class UserServiceImpl implements UserService &#123; @Override public List&lt;UserAddress&gt; getUserAddressList(String userId) &#123; System.out.println("调用到了消费者"); final UserAddress userAddress1 = new UserAddress() .setUserId(1L) .setAddressId(1L) .setAddressNo("123") .setAddressStr("庆丰大街") .setUserName("小张"); final UserAddress userAddress2 = new UserAddress() .setUserId(1L) .setAddressId(2L) .setAddressNo("456") .setAddressStr("西湖") .setUserName("小王"); return new ArrayList&lt;UserAddress&gt;()&#123;&#123; add(userAddress1); add(userAddress2); &#125;&#125;; &#125;&#125; 这里的关键是provider的xml配置： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="dubbo-demo" /&gt; &lt;!-- 注册的地址 --&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!-- 使用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 生命要暴露的服务接口 --&gt; &lt;dubbo:service interface="service.user.UserService" ref="userService" /&gt; &lt;!-- 实现服务 --&gt; &lt;bean id="userService" class="service.impl.UserServiceImpl" /&gt;&lt;/beans&gt; 其中的配置： application标签，提供了服务提供方应用信息，用于计算依赖关系和dubbo-admin中的界面信息 registry标签，这个标签标明了注册中心和注册中心的地址，这里可以支持多种协议和多种写法，具体见官方文档。 protocol标签，这里是暴露在20880端口的服务，这里的端口可以修改。 service标签，这里是声明要暴露的用户服务接口，ref为spring环境中的bean的id。 bean标签，这里是spring的操作，将实现作为spring bean管理。 这里可以简单的测试一下服务是否注册成功： 123456789101112public class TestProvider &#123; public static void main(String[] args) throws Exception &#123; // 加载spring配置 ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("provider.xml"); // 启动spring环境 applicationContext.start(); // 使程序hang住 不退出 System.in.read(); &#125;&#125; 启动这个测试程序后可以用telnet测试一下服务是否在本地的zk上注册上去 zk也可以看到多了一个dubbo节点： consumer同样consumer也要先实现order服务的接口 12345678910111213141516171819202122232425@Servicepublic class OrderServiceImpl implements OrderService &#123; @Resource private UserService userService; /** * 生成订单过程： * 调用远程接口 查询用户信息 * 将用户信息去生成订单 * @return */ @Override public boolean initOrder() &#123; List&lt;UserAddress&gt; userAddressList = userService.getUserAddressList("1"); if (null != userAddressList &amp;&amp; userAddressList.size() &gt; 0) &#123; System.out.println("调用远程接口完成"); Optional.of(userAddressList).ifPresent(System.out::println); &#125; return true; &#125;&#125; 配置对应的consumer.xml文件 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://dubbo.apache.org/schema/dubbo" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://dubbo.apache.org/schema/dubbo http://dubbo.apache.org/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;dubbo:application name="dubbo-demo" /&gt; &lt;dubbo:registry address="zookeeper://127.0.0.1:2181" /&gt; &lt;!-- 引用远程接口 --&gt; &lt;dubbo:reference id="userService" interface="service.user.UserService" /&gt; &lt;!-- 启动包扫描 --&gt; &lt;context:component-scan base-package="service.impl" /&gt;&lt;/beans&gt; 这里多了一个dubbo的reference标签，这里就是要引用刚才暴露的接口。 在实现里看到了将实现类作为spring bean管理，这里在xml中开启了包扫描。 这里去写一个简单的test程序去测试写的consumer程序： 123456789101112131415161718public class TestConsumer &#123; @SneakyThrows public static void main(String[] args) &#123; ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("consumer.xml"); // 启动spring环境 applicationContext.start(); // 拿到orderService这个bean OrderService bean = applicationContext.getBean(OrderService.class); // 调用 测试是否调用了远程接口 bean.initOrder(); System.in.read(); &#125;&#125; 同时这里也启动这个test类，看控制台中的输出观察是否调用了远程接口。 可以看到在TestConsumer控制台输出 12调用远程接口完成[UserAddress(addressId=1, addressNo=123, addressStr=庆丰大街, userName=小张, userId=1), UserAddress(addressId=2, addressNo=456, addressStr=西湖, userName=小王, userId=1)] 在TestProvider控制台输出 1调用到了消费者 可以看到调用成功。 github此次的代码已上传至github: github]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized锁对应的内存模型知识]]></title>
    <url>%2Fblog%2F2019%2F03%2F18%2Fsynchronized%E9%94%81%E5%AF%B9%E5%BA%94%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[背景synchronized锁在并发编程的学习和面试中都占有着比较重要的地位，而且]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次排查$jacocoData的过程]]></title>
    <url>%2Fblog%2F2019%2F03%2F10%2F%E4%B8%80%E6%AC%A1%E6%8E%92%E6%9F%A5-jacocoData%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[起因最近在开发过程中，遇到了一个奇怪的现象，在测试环境去利用反射拿一个类的字段时，发现拿到的field数组中多了一个奇怪的变量：$jacocoData，是一个static的boolean数组： 很明显jacoco这种统计代码覆盖率不是我定义在一个业务含义的类中，这时考虑到可能是测试环境中对代码覆盖率在编译时对字节码进行了修改，于是去测试环境的机器上看这个jar包。 疑惑点在机器上对jar包解压（解压命令jar -xvf xxxxxxx.jar），并且在对应的目录下找到对应的calss文件，注意这里解压之后的要看的字节码文件都在BOOT-INF目录的lib下： 将反编译的字节码复制了下来，却发现对应的字节码中并没有这个变量。 这里就不是网上说的很多编译时修改字节码来实现测试覆盖率的功能。 解决后来问了部署jacoco服务的框架组人员，发现是用了java Agent在修改运行时字节码实现的，拉了dump发现确实在运行时进行字节码修改的，而在jacoco官方的github也曾经有过这个问题的issue： jacocoData 关于java Agent技术可以参考博客:agent博客，这里提到了asm技术和agent探针参数。 所以在反射取字段时候遇到这个坑比较难排查，记录一下。这里的解决办法参考了博客:$jacocoData问题的解决，即使用了是否为复合字段的field方法解决。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>反射</tag>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dubbo基础（一）——概念及基本框架]]></title>
    <url>%2Fblog%2F2019%2F03%2F06%2Fdubbo%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[入门dubbo是公司选择rpc框架时首先会去选择的框架，好好了解dubbo框架是一个合格程序员的必经之路。这里作为dubbo的入门篇，把一些概念和官方文档搞清楚一定是最应该开始的步骤。 dubbo框架诞生的背景随着互联网的发展，网站应用的规模不断扩大，常规的垂直应用架构已无法应对，分布式服务架构以及流动计算架构势在必行，亟需一个治理系统确保架构有条不紊的演进。 单一应用架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架（ORM）是关键 垂直应用架构当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 分布式服务架构当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 流动计算架构当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需要增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）是关键dubbo框架满足的需求在大规模服务化之前，应用只能通过RMI或者Hessian等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过F5等硬件进行负载均衡。此时的诉求是，当服务越来越多时，服务的url配置就会变得非常复杂，负载均衡越来越难做。此时就需要一个服务注册中心，动态的注册和发现服务，使服务的位置透明。并且通过在消费方获取服务提供方地址列表，实现软负载均衡和FailOver（服务提供方挂掉之后的容灾）。这也是后来我们常见的注册中心zk、etcd等。当进一步发展，服务间的依赖关系变得错综复杂，架构关系很难去理清楚，这时候就有一个dubbo治理的需求。当服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？为了解决这些问题，第一步，将服务每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，可以动态调整权重，把某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此时访问量乘以机器数反推可以承受的总容量。 dubbo框架的整体架构节点角色说明 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册和发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 调用关系说明 服务容器负责启动、加载、运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 dubbo架构的特性可以看到dubbo架构具有以下几个特点：连通性、健壮性、伸缩性、以及向未来架构的扩展升级性。 连通性 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。 监控中心负责统计个服务调用次数、调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以可视化方式展示。（在架构图中可以看到这个是异步发送的） 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此事件不包含网络开销 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销。 注册中心、服务提供者、服务消费者三者之前均为长连接 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心立即推送事件通知消费者。 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者本地缓存了提供者列表。 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。健壮性 监控中心宕机不影响使用，只是丢失部分采样数据 数据库宕机后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务 注册中心对等集群，任意一台宕机后，将自动切换至另一台。 注册中心全部宕机，服务提供者和服务消费者仍能通过本地缓存通讯 服务提供者无状态，任意一台宕机后，不影响使用 服务提供者全部宕机后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复 伸缩性 注册中心对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心。 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者。升级性当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：节点说明：| 节点 | 角色说明 || ———- | ————————————– || Deployer | 自动部署服务的本地代理 || Repository | 仓库用于存储服务应用发布包 || Scheduler | 调度中心基于访问压力自动增减服务提供者 || Admin | 统一管理控制台 || Registry | 服务注册和发现的注册中心 || Monitor | 统计服务的调用次数和调用时间的监控中心 |]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——装饰者模式]]></title>
    <url>%2Fblog%2F2019%2F03%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰者模式装饰者模式是java IO流中使用的一个经典模式，本文会简单介绍装饰者模式的原理和解决的问题，并且以一个咖啡demo来演示装饰者模式。 装饰者模式的定义装饰者模式遵守的设计原则：开闭原则（类应该支持扩展，而拒绝修改） 装饰者模式通过组合的方式扩展对象的特性，这种方式允许我们在任何时候对对象的功能进行扩展甚至是运行时扩展，而若我们用继承来完成对类的扩展只能在编译时实现，可以比较动态地对对象进行扩展，某些情况下，装饰者模式比继承更加灵活。 装饰者模式的一些特征 装饰者（decorator）和被装饰（扩展）的对象有着相同的超类。 可以用多个装饰者装饰一个对象。 可以用装饰过的对象替换代码中的原对象，（因为有相同的超类） 装饰者可以在委托（delegate，即调用被装饰的类的成员完成一些工作）被装饰者的行为完成之前或者之后加上他自己的行为 一个对象在任何时候都能被装饰，甚至是运行时。 装饰者模式的结构 Component：一般是一个抽象类，表示一组有着某种用途的基类，包含着这些类最基本的特性。 ConcreteComponent:继承自Component，一般是一个有实际用途的类，这个就是直接的被装饰者。 Decorator：继承自Component，装饰者需要实现的接口（可以是抽象类），用来保证装饰者和被装饰者用共同超类，并保证每一个装饰者有一些必须具有的性质。 ConcreteDecorator：继承自Decorator，用来装饰Component类型的类（ConcreteComponent），但是不能装饰抽象类，为其添加新的特性，可以在委托被装饰者的行为完成之前或之后的任意时候。 装饰者模式的实例一个比较经典的咖啡案例：咖啡馆提供不同种口味的咖啡和咖啡的调料，我们需要一个程序来描述并且计算出任意一种咖啡和任意几种调料搭配在一起的价格。 最初继承的设计最容易想到的是用继承去实现这个需求，定义一个超类，其中只对cost做一个抽象，而让所有的咖啡和调料品之间的组合都去继承这个超类，这样一个设计的坏处是类会爆炸，并且当一种咖啡中调料要变化的时候，要修改原来的类，并且会造成大量的冗余。 好一点的调料放入超类方案也可以想到的是将调料作为一个Boolean变量放入超类中，这样真正的咖啡在继承超类的同时也可以设置想配合的不同调料品。但是这样做的一个缺陷点是如果要引入一个新的调料或者丢弃一个原来的调料，则要对超类进行修改，灵活性受到了很大的挑战。 用装饰者模式去做这个需求 这就是装饰者模式解决这个咖啡馆项目的设计图。 可以看到有一个超类Drink,这个就相当于我们装饰者模式中的Component，可以看到在这个超类中有描述变量、价格变量和cost方法。同时cost方法是一个抽象方法，而子类去实例化时去初始化对应的描述和价格变量。 对应的代码： 123456789101112131415161718192021222324252627/** * 装饰者模式：动态的将新功能附加到对象上，在对象扩展方面，它比继承更有弹性 * 咖啡和调料这么一个项目 * 饮料作为装饰者模式的一个主体 定义一些饮料都有的方法 同时主体也要作为变量在装饰者中定义，装饰者也要继承主体 * * Drink是一个超类 * @date 2019/3/2 17:53 */@Setterpublic abstract class Drink &#123; private String desc; @Getter private float price=0f; public String getDesc() &#123; return desc + "-" + this.getPrice(); &#125; /** * 供子类去实现计算价格的方法 抽象方法 * @return */ public abstract float cost();&#125; 左边的ShortBlack、Decaf等单体咖啡是装饰者模式中的ConcreteComponent，这些子类中都去实现了cost方法，这里注意这个cost方法的实现，因为每个子类都要去实现cost方法，所以可以做一个中间层去实现这个cost方法，对于这里的cost即为返回子类实例化时在构造函数中填充的父类中的price变量值。 123456789101112131415/** * 单体的一个中间层，这里实现了cost方法 * 这里coffee单体 继承了Drink超类，其实cost的计算就是计算他们给price赋值的价格 * * 引入新的单体咖啡时，不会修改之前的单体咖啡代码，只需要继承这个中间层类即可 * * Created by zlj on 2019/3/3. */public class Coffee extends Drink &#123; @Override public float cost() &#123; return super.getPrice(); &#125;&#125; 一个单体咖啡子类的写法： 1234567891011/** * Created by zlj on 2019/3/3. * 一种单体咖啡 */public class LongBlack extends Coffee &#123; public LongBlack() &#123; super.setDesc("LongBlack"); super.setPrice(5.0f); &#125;&#125; Decorator类即装饰者模式中的Decorator，即为装饰者类的一个抽象，这个类由装饰者模式的定义结构我们可以知道也是继承了Component也就是Drink类的，同时，它也定义了一个Drink类型的变量，这里即用父类定义了要装饰的单体咖啡。因为它继承自Drink类，所以它也要去实现抽象方法cost方法，这里注意因为要在调用时展示一个咖啡的描述和价格时，作为装饰者需要将被装饰者和其他组合在一起的装饰者价格和描述一起展示出来，所以实现是将装饰者的描述和价格 同 被装饰者的描述和价格一起递归显示，所以代码如下，这里的Decorator也相当于真正装饰者的一个抽象或者中间层。这里也要注意装饰者可以装饰一个单体咖啡，也可以装饰一个被装饰过的装饰者。 12345678910111213141516171819202122232425262728293031323334353637/** * 装饰者的一个中间层 其实就是装饰者类 这里装饰的是主体咖啡， 而继承装饰者的都是咖啡中的调料 * * 1. 装饰者类是要继承主体类 * 2. 装饰者可以直接装饰主体，也可以是已经被装饰者包装过的，就是多个调料 * 3. 装饰者要定义一个主体变量在其中 * * 当要拓展 一个新的装饰者时，直接继承装饰者中间层类即可。 * Created by zlj on 2019/3/3. */public class Decorator extends Drink &#123; /** * 被装饰的主体变量 */ private Drink obj; public Decorator(Drink obj) &#123; this.obj = obj; &#125; /** * 这里也去实现cost方法，因为本身装饰者也是有价格的 * 这里的obj.cost() 如果obj是一个被装饰过的类，这里会进行递归计算 * @return */ @Override public float cost() &#123; return super.getPrice() + obj.cost(); &#125; @Override public String getDesc() &#123; return super.getDesc() + "&amp;&amp;" + obj.getDesc(); &#125;&#125; 图中的Soy、Milk类就是其中的调料类，这个要继承Decorator，作用其实就是ConcreteDecorator。这里的作用其实比较简单，其实就是传入被装饰对象（上边也提到这里可以是单体咖啡和被装饰过的装饰者），还有就是把描述和价格填上。 1234567891011121314/** * 单个继承装饰者的调料类 * 要在构造函数中将装饰的对象 设置进去 * * Created by zlj on 2019/3/3. */public class Chocolate extends Decorator &#123; public Chocolate(Drink obj) &#123; super(obj); super.setDesc("Chocolate"); super.setPrice(1.0f); &#125;&#125; 简单测试做一个简单的程序测试一下装饰者模式： 1234567891011121314151617181920212223242526272829303132333435363738public class TestMain &#123; public static void main(String[] args) &#123; /** * 只是点了一个单体咖啡 */ Drink order1; order1 = new Espresso(); System.out.println(order1.getDesc()); System.out.println("*******************************"); /** * 点有调料的咖啡 */ Drink order2; // 先是一杯单体咖啡 order2 = new LongBlack(); // 加牛奶 order2 = new Milk(order2); // 加巧克力 order2 = new Chocolate(order2); // 加盐 order2 = new Soy(order2); System.out.println(order2.getDesc() + "总共钱： " + order2.cost()); &#125;&#125;// 运行结果：Espresso-2.0*******************************Soy-3.0&amp;&amp;Chocolate-1.0&amp;&amp;Milk-2.0&amp;&amp;LongBlack-5.0总共钱： 11.0 java中的装饰者模式文章一开始就提到了java中的IO流使用了装饰者模式，这里简单的去看一个FilterInputStream类，而它继承的InputStream类即装饰者中的Component类，该类其实就是装饰者的中间层，可以看到其中定义了InputStream的变量引用，而其子类BufferInputStream、DataInputStream、LineNumberInputStream等是ConcreteDecorator。结构如下： 也可以看到代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455publicclass FilterInputStream extends InputStream &#123; // 被装饰的变量 protected volatile InputStream in; protected FilterInputStream(InputStream in) &#123; this.in = in; &#125; public int read() throws IOException &#123; return in.read(); &#125; public int read(byte b[]) throws IOException &#123; return read(b, 0, b.length); &#125; public int read(byte b[], int off, int len) throws IOException &#123; return in.read(b, off, len); &#125; public long skip(long n) throws IOException &#123; return in.skip(n); &#125; public int available() throws IOException &#123; return in.available(); &#125; public void close() throws IOException &#123; in.close(); &#125; public synchronized void mark(int readlimit) &#123; in.mark(readlimit); &#125; public synchronized void reset() throws IOException &#123; in.reset(); &#125; public boolean markSupported() &#123; return in.markSupported(); &#125;&#125; 再唠叨几句装饰者和继承装饰者模式中用到了继承，但是这里装饰者模式用继承是为了保证装饰者和被装饰者有共同的超类，而不是为了给被装饰的类扩展新的特性，而装饰者模式中新的特性是通过类与类的组合（has-a的关系）而得到的，所以把装饰者模式和继承看做同一类设计思想是不恰当的。 装饰者模式的优点针对第一种继承的方案：装饰者模式减少了代码的类，只定义了基础的Component和Decorator，而是通过组合的方式实现具体的咖啡的。 针对第二种在超类中定义Boolean变量的方案，装饰者模式提高了灵活性，当你需要加入新的调料或者单体咖啡时，只需定义新的ConcreteComponent和ConcreteDecorator即可。而当你想对一个已有加过调料的咖啡进行再装饰时，也只需要将对应的调料装饰上去即可，价格和描述即可递归显示。 参考http://www.cnblogs.com/coffeeSS/p/5405787.html 《headFirst 设计模式》 代码在github: https://github.com/zhanglijun1217/design_mode/tree/master/src/main/java/decorator]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用telnet测试dubbo接口初使用]]></title>
    <url>%2Fblog%2F2019%2F02%2F25%2F%E4%BD%BF%E7%94%A8telnet%E6%B5%8B%E8%AF%95dubbo%E6%8E%A5%E5%8F%A3%E5%88%9D%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景dubbo接口的测试不像controller的http接口那么容易测试，这里去了解了下使用telnet去测试参数没那么复杂的dubbo接口。 正题首先看看一个dubbo接口的代码： 12345678910111213141516public interface ShopAggregateRemoteService &#123; /** * 获取所有产品类型 聚合字段的产品类型范围[软件+有伴服务] * @param careDeleteFlag 是否关心软删 true：只返回生效的 false：全部返回 * @return */ ListResult&lt;AggregateProductTypeDTO&gt; getAllAggregateProductType(boolean careDeleteFlag); /** * 获取所有产品类型 聚合字段的产品类型范围[软件+有伴服务] * @return */ default ListResult&lt;AggregateProductTypeDTO&gt; getAllAggregateProductType() &#123; return getAllAggregateProductType(false); &#125;&#125; 里面的实现：(就是一个简单的查数据库操作) 123456789101112@Overridepublic ListResult&lt;AggregateProductTypeDTO&gt; getAllAggregateProductType(boolean careDeleteFlag) &#123; AggregateProductTypeCriteria example = new AggregateProductTypeCriteria(); AggregateProductTypeCriteria.Criteria criteria = example.createCriteria(); if (careDeleteFlag) &#123; // 关心软删 加入软删标志 criteria.andDeleteFlagEqualTo(0); &#125; return DTOWrapper.wrap(customerConverter.convertList(aggregateProductTypeMapper.selectByCondition(example), AggregateProductTypeDTO.class));&#125; 这里想本地启动项目去测试一下这个接口有没有问题，这个参数也比较简单（这里直接调用default方法就可以了）。 这里使用的mac系统，但是mac系统中高版本未默认安装telnet，所以还需要brew去安装一下。 brew install telnet 安装完成之后，就可以在本地将服务启动。 输入命令去telnet这个服务的dubbo接口： telnet localhost 7100 然后可以看到进入到了dubbo的命令行界面： 这里可以用dubbo的ls命令去查看有什么dubbo服务： 最后是我们的invoke调用这个命令 invoke com.youzan.xxx.getAllAggregateProductType() 可以看到结果是调通的： 总结这里使用的dubbo的简单命令去测试了工作中的一个接口，之后会对dubbo的使用和测试做更多的分析。]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>telent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——线程状态（2）]]></title>
    <url>%2Fblog%2F2019%2F02%2F24%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线程的状态线程的状态很早之前就理解过了，最近翻《并发编程艺术》的书时候，看到有个点之前理解的不太对。 书中的线程状态分类 new 初始状态，线程被构建，但是还没有调用start()方法 runnable 运行状态，java中将操作系统中的就绪和运行两种状态笼统称作”运行中“（这里没有网上常见的Running状态） blocked 阻塞状态，表示线程阻塞于锁 waiting 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断） time_waiting 超时等待状态，该状态不同于waiting，可以在指定的时间自行返回。（可以看到这里将waiting和time_waiting分开了，这样也很符合我们用jstack命令看到的线程状态信息） terminated 终止状态，表示线程已经执行完毕。 一个线程状态演示的例子在书中有这样的一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Created by zlj on 2019/2/23. */public class ThreadState &#123; public static void main(String[] args) &#123; // TimeWaiting 状态的线程 new Thread(new TimeWaiting(), "TimeWaitingThread").start(); // Waiting状态的线程 new Thread(new Waiting(), "WaitThread").start(); // 模拟同步锁 即未抢占到锁的线程为blocked状态的线程 new Thread(new Blocked(), "BlockedThread-1").start(); new Thread(new Blocked(), "BlockedThread-2").start(); &#125; /** * 不断的进行睡眠 模拟线程的超时等待状态 */ static class TimeWaiting implements Runnable &#123; @Override public void run() &#123; while (true) &#123; SleepUtils.second(1000); &#125; &#125; &#125; /** * 该线程在Waiting.class上进行等待 模拟线程的等待状态 */ static class Waiting implements Runnable &#123; @Override public void run() &#123; while (true) &#123; synchronized (Waiting.class) &#123; try &#123; // 进行等待 Waiting.class.wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; &#125; &#125; /** * 模拟线程阻塞状态，一个线程获取了Blocked.class的锁 并且不会释放该锁 */ static class Blocked implements Runnable &#123; @Override public void run() &#123; synchronized (Blocked.class) &#123; while (true) &#123; SleepUtils.second(1000); &#125; &#125; &#125; &#125;&#125; 这里用了jps和jstack命令去观察了线程状态： 12345678910111213141516171819202122232425262728293031323334// blockedThread-2线程阻塞在获取Blocked.class的锁上"BlockedThread-2" #15 prio=5 os_prio=0 tid=0x000000001a27a800 nid=0x31dc waiting for monitor entry [0x000000001b11e000] java.lang.Thread.State: BLOCKED (on object monitor) at lesson.wwj.juc.thread_status.ThreadState$Blocked.run(ThreadState.java:63) - waiting to lock &lt;0x00000000d5c3e6d0&gt; (a java.lang.Class for lesson.wwj.juc.thread_status.ThreadState$Blocked) at java.lang.Thread.run(Thread.java:745)// 获取到了锁 "BlockedThread-1" #14 prio=5 os_prio=0 tid=0x000000001a278800 nid=0x4538 waiting on condition [0x000000001b01e000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at java.lang.Thread.sleep(Thread.java:340) at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386) at lesson.wwj.juc.thread_status.SleepUtils.second(SleepUtils.java:12) at lesson.wwj.juc.thread_status.ThreadState$Blocked.run(ThreadState.java:63) - locked &lt;0x00000000d5c3e6d0&gt; (a java.lang.Class for lesson.wwj.juc.thread_status.ThreadState$Blocked) at java.lang.Thread.run(Thread.java:745)// 处于waiting状态的线程"WaitThread" #13 prio=5 os_prio=0 tid=0x000000001a274000 nid=0x4c84 in Object.wait() [0x000000001af1f000] java.lang.Thread.State: WAITING (on object monitor) at java.lang.Object.wait(Native Method) - waiting on &lt;0x00000000d5c3b5a0&gt; (a java.lang.Class for lesson.wwj.juc.thread_status.ThreadState$Waiting) at java.lang.Object.wait(Object.java:502) at lesson.wwj.juc.thread_status.ThreadState$Waiting.run(ThreadState.java:44) - locked &lt;0x00000000d5c3b5a0&gt; (a java.lang.Class for lesson.wwj.juc.thread_status.ThreadState$Waiting) at java.lang.Thread.run(Thread.java:745)// 处于超时等待的线程"TimeWaitingThread" #12 prio=5 os_prio=0 tid=0x000000001a25f000 nid=0x5b44 waiting on condition [0x000000001ae1f000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at java.lang.Thread.sleep(Thread.java:340) at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386) at lesson.wwj.juc.thread_status.SleepUtils.second(SleepUtils.java:12) at lesson.wwj.juc.thread_status.ThreadState$TimeWaiting.run(ThreadState.java:27) at java.lang.Thread.run(Thread.java:745) 书中的状态转换图 这里要注意的一点：阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或者代码块（获取锁）时的状态，但是阻塞在java.concurrent包中Lock接口的线程状态却是等待状态，因为Lock接口对于阻塞的实现均使用了LockSupport类中相关的方法。]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>线程状态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——Thread API]]></title>
    <url>%2Fblog%2F2019%2F02%2F21%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94Thread-API%2F</url>
    <content type="text"><![CDATA[这篇主要介绍Thread API，也是并发编程中的基础 Thread一些常用API守护线程 守护线程的概念和原理可以见：守护线程和非守护线程 守护线程的一个应用： 比如在做长连接的时候，需要一个心跳检查线程，这个线程就应该设置为后台线程，这样当整个连接关闭时，也会跟随连接线程消亡。 在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑，会有可能不去执行。 这里可以在一个线程中再创建一个后台线程，来验证上述的这个应用： 12345678910111213141516171819202122232425262728293031323334353637/** * 这里对后台线程提出一个问题： * （1）当在main函数中的一个Thread里再创建一个线程，设置为后台线程，那么外边线程结束之后 里面的线程是否也会退出？ 会的 这个就长连接中的健康检查 * * * @author 夸克 * @date 2019/2/19 00:21 */public class DaemonQuestionThread &#123; public static void main(String[] args) &#123; Thread outerThread = new Thread(() -&gt; &#123; Thread innerThread = new Thread(() -&gt; &#123; try &#123; while (true) &#123; System.out.println("do Something for health check"); Thread.sleep(1_000); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); // 设置一个守护线程 设置的过程必须在start方法之前 innerThread.setDaemon(true); innerThread.start(); &#125;); try &#123; Thread.sleep(1_000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; outerThread.start(); System.out.println("程序结束"); &#125;&#125; 线程id线程id是Thread类在构造函数初始化时赋值给的Thread类中的tid字段，而赋值时其实调用的是静态的加锁方法nextThreadId()。可以看下源码： 123private static synchronized long nextThreadID() &#123; return ++threadSeqNumber;&#125; 其实就是对Thread类中的静态字段threadSeqNumber自增。 12/* For generating thread ID */ private static long threadSeqNumber; 线程优先级概念： OS是采用分时间片的形式调度运行的线程，OS会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。 是一个和操作系统有关的线程属性，有的操作系统直接回忽略用户设置线程的优先级。 IO密集型是要设置高线程优先级的，cpu密集型是要设置低优先级的。 join方法 一个线程调用join方法其实就是让被join的线程等待该线程执行完毕之后再执行。下面是java代码示例。可以看到join其实也是通过wait()方法去实现的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 哪个线程去调用join方法 就可以在加的线程内先执行该线程完毕之后才执行外部线程 * * join方法可以加时间控制 * join方法的底层实现其实是wait * * @author 夸克 * @date 2019/2/20 00:11 */public class ThreadJoinTest &#123; public static void main(String[] args) &#123; Thread t1 = new Thread(() -&gt; &#123; // t1线程 IntStream.range(1, 1000).forEach(i -&gt; System.out.println(Thread.currentThread().getName() + "--" + i)); &#125;); t1.start(); Thread t2 = new Thread(() -&gt; &#123; // t2线程 IntStream.range(1, 1000).forEach(i -&gt; System.out.println(Thread.currentThread().getName() + "--" + i)); &#125;); t2.start(); // try &#123; // 调用了t1.join 会先输出t1 再输出t2 t1.join(); t2.join();// 这样写了之后 对于main线程来说 必须等到t1 和 t2线程执行完毕 才能执行main线程 但是对于t1 和 t2 是交替执行的 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("==================t1 和 t2执行完毕================"); IntStream.range(1, 1000).forEach(i -&gt; System.out.println(Thread.currentThread().getName() + "--" + i)); // 如果这里调用 Thread.currentThread.join 则会出现程序无法关闭的问题。 main线程自己join了自己的情况// try &#123;//// Thread.currentThread().join();// &#125; catch (Exception e) &#123;// e.printStackTrace();// &#125; &#125;&#125; 这里再补充一个join的小demo：比如要每个线程去采集对应服务器的数据，现在有三台服务器，每台除了要记录对应服务器采集的时间外，还要在主线程中输出一共消耗了多少时间。这个就是一个join方法的简单应用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Thread.join方法的一个小demo ： * 假设有四台服务器，每个线程要对每台服务器采集信息，比如不同的服务器采集需要不同的时间， * 这里要求主线程去记录时间的时候，必须等待每个线程采集信息完毕 * * @author 夸克 * @date 2019/2/20 00:29 */public class ThreadJoinDemo &#123; public static void main(String[] args) &#123; // 模拟三个服务器 long begin = System.currentTimeMillis(); Thread thread1 = new Thread(new CaptureRunnable("m1", 1_000)); Thread thread2 = new Thread(new CaptureRunnable("m2", 2_000)); Thread thread3 = new Thread(new CaptureRunnable("m3", 3_000)); thread1.start(); thread2.start(); thread3.start(); // 这里必须调用join 才能保证每个线程执行完毕 try &#123; thread1.join(); thread2.join(); thread3.join(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; // 因为是每个服务器 并行采集 所以这里的最长应该是t3的 System.out.println("采集信息完毕,最长花费时间：" + (System.currentTimeMillis() - begin)); &#125;&#125;class CaptureRunnable implements Runnable &#123; private String name; private long expiredTime; public CaptureRunnable(String name, long expiredTime) &#123; this.name = name; this.expiredTime = expiredTime; &#125; @Override public void run() &#123; try &#123; long beginTime = System.currentTimeMillis(); Thread.sleep(expiredTime); System.out.println(Thread.currentThread().getName() + "采集信息花了" + (System.currentTimeMillis() - beginTime)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; interrupt方法 interrupt方法是Thread API中一个重要的方法。interrupt方法是Thread类提供的一个线程中断机制，这个方法的原理是给线程设置一个为true的中断标志，设置之后，会根据线程的状态有不同的结果。如果当前线程处于阻塞状态，那么将中断标志设为true后，如果是由join、wait、sleep引起的阻塞状态，那么会将线程的中断标志设置回false，并且抛出一个InterruptedException；如果打断时当前线程处于非阻塞状态，那么仅仅会将线程中的中断 标志设置为true，在之后如果线程进入了阻塞状态，也会立马抛出一个InterruptedException，且中断标志被清除，重新设置为false。 所以对于interrupt方法，可以知道调用了interrupt方法之后线程不一定会中断，它只是将线程的中断标志位设置为true，而是否抛出InterruptedEx是根据线程的阻塞状态相关。它更像是线程的一个协作机制，线程A需要中断B线程，那么调用B.interrupt()进行线程的协作。 我们可以看看其中的源码： 在Thread类中，有一个变量blocker来表示线程的中断标志位，对于这个字段我们可以知道它的默认值是null，之后我们的理解其实可以简单的认为当中断标志位设置了，就是true，而中断标志位被清除了，就是false了。 1private volatile Interruptible blocker; 而关于中断有三个方法： public void interrupt(); 这个方法就不去赘述了，作用就是设置中断标志位为true，如果当前 public static boolean interrupted(); 和 public boolean isInterrupted(); 这两个方法前者是静态方法，后者是类实例方法，都返回了当前线程是否被中断。主要有两个区别： （1）静态方法提供了一种访问的方式，比如初始化Thread中传入lambda表达式作为Runnable接口的方式，这样无法在当前内部类中调用线程实例的判断方法，有了前者方法就可以直接调用静态方法，获取当前线程是否被中断。 123456789101112Thread thread = new Thread(() -&gt; &#123; while (true) &#123; try &#123; Thread.sleep(100);// 阻塞状态 清除中断标志位 抛出异常 &#125; catch (Exception e) &#123; System.out.println(&quot;收到打断信号&quot;); // 这里就是外边的interrupt方法打断了这里的sleep e.printStackTrace(); &#125; System.out.println(&quot;&gt;&gt;&quot; + Thread.currentThread().getName() + &quot;..&quot; + Thread.interrupted()); &#125;&#125;); （2）前者静态方法，会判断当前线程是否已经中断。线程的中断状态 由该方法清除。线程中断被忽略，因为在中断时不处于活动状态的线程将由此返回 false 的方法反映出来。而后者实例方法，判断线程是否已经中断。线程的中断状态 不受该方法的影响。线程中断被忽略，因为在中断时不处于活动状态的线程将由此返回 false 的方法反映出来。这里区别是静态方法会清除线程的中断标志，这里可以分析源码得到： 123456789public static boolean interrupted() &#123; return currentThread().isInterrupted(true);&#125;public boolean isInterrupted() &#123; return isInterrupted(false);&#125;private native boolean isInterrupted(boolean ClearInterrupted); 可以看到其实两个方法都是调用的native方法isInterrupted方法，但是静态方法传入的参数是true，而实例方法传入的是false，这个参数的含义很清晰就是控制是否清楚当前中断标志位。 这里关于interrupt方法不能真正中断线程的实现，也可以在源码中得到，同时也能解释为什么当线程处于阻塞状态时，调用interrupt()方法，会抛出InterruptedException，并且将标志位清空。 123456789101112131415public void interrupt() &#123; if (this != Thread.currentThread()) checkAccess(); synchronized (blockerLock) &#123; Interruptible b = blocker; // blocker为空时不会进入到if的判断，所以只会调用synchronized代码块之后的最后的interrupt0方法，而从注释来看这个native方法仅仅是设置interrupt标志位的 if (b != null) &#123; interrupt0(); // Just to set the interrupt flag b.interrupt(this); // 真正执行中断线程的方法 return; &#125; &#125; interrupt0();&#125; 这个时候当线程中的中断标志位为空时，很明显不会进入if的判断，这时只是会设置当前线程的中断标志位。而且这时也没有进入的if中的interrupt真正中断线程的方法。 而当线程阻塞时，以sleep方法为例，在调用sleep时，就会调用native方法interrupt0，这个方法会将线程标志位设置为true，并且现在blocker标志肯定不为null。所以会进入到if的判断代码块中，这时会再调用一次interrupt0方法（调用这个方法会清除当前线程的标志位），并且使当前线程退出阻塞状态（调用了真正的中断线程的方法）并且抛出InterruptedException异常。见下图 InterruptedException异常的处理 这里要规范的处理方法有两种： （1） 把该类异常抛给上层调用者来处理（当然，抛出去后，接收者也要考虑这个同样的问题） （2）在 catch 该异常后，通过 interrupt() 方法恢复当前线程的中断状态，示例如下： 12345678910try &#123; Thread.sleep(100);// 阻塞状态 清除中断标志位 抛出异常&#125; catch (InterruptedException e) &#123; System.out.println("收到打断信号"); // 这里就是外边的interrupt方法打断了这里的sleep e.printStackTrace(); // 正确的处理InterruptException的一种方式 Thread.currentThread().interrupt();// 通过这个回复线程的中断标志位，给下面的操作处理&#125; 这样原因已经比较清楚了：出现了 InterruptedException，说明当前线程在 wait / sleep / join 时的阻塞（等待）状态下被打断，此时 JDK 的实现默认会退出阻塞，并且清除了中断状态。也即是讲，如果此时通过 isInterrupted() 去读取中断状态时，得到的是 false。而这与 interrupt() 的调用目的是违背的，因为 interrupt 的目的是请求和标记目标线程的中断。如果我们不去主动恢复中断状态，就会导致其他需要读取中断状态的地方 判断错误，导致一些意外情况的发生。 interrupt这里的参考 一个interrupt方法的详解 interrupt的用途 关于InterruptedException的思考 交流上述代码都能在github中找到:]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>Thread API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——模板方法的应用]]></title>
    <url>%2Fblog%2F2019%2F02%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[模板方法模板方法很多情况下代码中的业务都可以抽象出一个模板去解决，这时候经常需要用到模板方法。大家经常接触到的是一些业务方法的抽象模板，比如在计算优惠券的流程当中总是有一定的步骤： （1）先计算该商品是否可以拥有优惠券信息 （2）再为该商品绑定优惠券信息 （3）最后回调或者通知向下的流程 今天要记录的是一个通用服务层的模板方法，包含了前置校验、后置处理（是有点像拦截器= =）、finally操作。 业务processor 可以定义一个domainProcessor去代表业务操作的processor接口，这个接口可以承接泛型。 123456789public interface DomainProcessor&lt;T&gt; &#123; /** * 处理业务的方法 返回值现在是void的 也可以自己定义一个通用的类似于上下文的返回值 * * @param context */ void process(T context);&#125; 这里承接的泛型context是一个上下文的概念，指的是在一个业务处理processor中的上下文信息，其中可以有计算的参数，计算的结果和一些中间信息。 做一个抽象类，去将其中的前置操作、biz操作、后置操作、finally操作定义出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public abstract class AbstractProcessor&lt;T&gt; implements DomainProcessor&lt;T&gt; &#123; /** * 前置处理 主要做一些校验逻辑 编排的时候放在前边 * * @param context * @return */ protected boolean preHandle(T context)&#123; return true; &#125; /** * 业务处理 这个是抽象方法 子类去实现具体的逻辑 * @param context */ protected abstract void bizHandle(T context); /** * 后置处理 * * @param context */ protected void postHandle(T context) &#123; &#125; /** * last 操作 * @param context */ protected void finallyHandle(T context) &#123; &#125; /** * 异常处理 * * @param context * @param e */ protected void exceptionHandle(T context, Exception e) &#123; // TODO 打印error或者warn级别日志 throw new BizException(e.getMessage(), e); &#125; @Override public void process(T context) &#123; /** * 编排流程 */ try &#123; if (!preHandle(context)) &#123;// log.warn("处理器前置处理失败，退出。context:&#123;&#125;", context); return; &#125; // 业务方法 bizHandle(context); // 后置操作 postHandle(context); &#125; catch (Exception e) &#123; exceptionHandle(context, e); &#125; finally &#123; finallyHandle(context); &#125; &#125;&#125; 可以看到，这里定义了前置操作，这里可以去对biz要用的参数进行一个校验或者一些前置操作，同时将biz定义为了抽象方法，意图在为了让子类去继承时一定要去实现bizHandle这个方法。而exceptionHandle和finallyHandle方法则定义了异常的处理和最终要做的（比如线程快照的清除）。而整个process方法其实就是整个处理器的入口，即对这整个流程的一个编排。 可以看一个这个模板processor的的具体实现和测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AbstractProcessorTest &#123; private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; // TODO test TestContext testContext = new TestContext(); contextHolder.set("aaa"); TestProcessor testProcessor = new TestProcessor(); // 调用process的编排 testProcessor.process(testContext); TestContext exContext = new TestContext(); // test bizHandle testProcessor.process(exContext); &#125; private static class TestProcessor extends AbstractProcessor&lt;TestContext&gt; &#123; @Override protected boolean preHandle(TestContext context) &#123; // 前置的一个check或者一个前置操作 String s = contextHolder.get(); if (s == null) &#123; throw new RuntimeException("holder中字符串为空"); &#125; context.setMessage(s); return true; &#125; @Override protected void postHandle(TestContext context) &#123; context.setPostStr("post"); System.out.println("processor 结果是："+ context.isResult()); &#125; @Override protected void finallyHandle(TestContext context) &#123; if (context.isResult()) &#123; contextHolder.remove(); &#125; &#125; @Override protected void bizHandle(TestContext context) &#123; context.setResult(context.getMessage().length()&gt;0); &#125; &#125;&#125; 总结这个模板可以作为之后一个处理器的抽象模板，能让代码逻辑很清晰的展现出来，也能解耦了各个处理模块，这里可以总结下。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——基础拾遗]]></title>
    <url>%2Fblog%2F2018%2F12%2F31%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E6%8B%BE%E9%81%97%2F</url>
    <content type="text"><![CDATA[并发编程基础拾遗在看并发的书或者看并发相关的博客时，会发现一些知识点会遗漏或者之前没有看到，这里去总结一下。 创建线程相关 main线程我们通常会通过写main方法去创建多个线程，main线程是非守护线程，代表方法的入口。这个时候如果用jconsole去看的话，会发现这时也会启用很多后台线程：比如GC线程、计算引用线程、JMX线程。 线程生命周期 新建状态 可运行状态 运行状态 阻塞状态 死亡状态 这些个状态之间的转换每次都记得不是很牢固。 当新建一个线程之后，这个线程处于新建状态，这时调用t.start()方法，线程就会进入可运行状态，这个状态下线程还没有真正的执行。当os分配给当前线程时间片的时候，线程会进入运行状态。当线程处于运行状态时，时间片用完或者调用Thread.yield()方法，线程则变回为可运行状态，同样若再获得os的时间片，线程将会再次进入运行状态。当正在运行状态的线程遇到Thread.sleep或者其他线程join的时候，会进入阻塞状态，直到sleep结束或者join线程结束之后线程进入可运行状态等待时间片的分配。（这里不能直接由阻塞状态直接变为运行状态）。当线程处于运行状态的时候，对象调用了o.wait方法，那么线程就会进入等待队列，等待被其他线程唤醒进入锁池，还有如果线程未持有对象的锁而被阻塞的时候也会进入到锁池，直到拿到对象锁标志之后，才能到可运行状态，再次等待时间片的分配。当线程的run方法结束，或者线程是一个守护线程是main线程结束，或者异常退出之后，线程进入到死亡状态。 start()方法和run方法的一个设计start方法和run()方法是Thread类中的两个方法，我们启动一个线程的时候要调用start方法。 123456789101112131415161718192021public synchronized void start() &#123; if (threadStatus != 0) throw new IllegalThreadStateException(); group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125;&#125; 在start方法里是调用了一个start0的native方法，这个方法其实是调用的run方法。 123456@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 这样的设计是体现的设计模式中的一个简单模板方法，在调用start方法的同时其实是调用你重写的run方法，其他的start0和一些线程状态的判断都在start方法中作为不变的部分，而变的run方法则供使用者去实现run方法。 Runnable接口相关runnable接口的作用Runnable接口创建线程，这种创建线程的方式可以将run方法的逻辑从new thread的控制中抽离出来，这里如果耦合在new Thread中，没有体现业务可执行逻辑和线程控制分离开，体现了面向对象的思想。其实这种方式体现的是一种策略模式，Runnable接口就像策略模式中的策略接口，实现Runnable接口的run方法的类都是一个线程运行的策略，同时Runnable设计成了函数式接口，也更加灵活。 Thread API相关new Thread构造函数Thread构造函数有多个参数的重载，这里去记录下相关的构造函数，并且每个构造函数中参数的含义。 new Thread()创建线程对象Thread，默认有一个线程名，以Thread-开头，从0开始数。 new Thread(Runnable target)如果在构造Thread的时候没有传递Runnable或者没有复写Thread的run方法，该Thread将不会调用任何东西，如果传递了Runnable接口的实例，或者复写了Thread的run方法，则会执行该方法的逻辑单元（逻辑代码）。 new Thread(ThreadGroup g)在创建线程的时候，如果构造函数中未传入threadGroup，则thread会默认获取父线程的threadGroup作为该线程的threadGroup。此时子线程和父线程将会在同一个ThreadGropu中。这时候可以通过threadGroup提供的api去获取一些信息。 比如threadGroup.getActiveCount 获取活跃线程数。 比如threadGroup.enumerate(new Thread[]) 是将所有活跃线程枚举到一个数组中。 new Thread(long stackSize)stackSize是平常用的比较少的，这里要清楚jvm的一个结构：（这里简单用图去展示了jmm和虚拟机栈中栈帧结构）。jmm的结构： 关于变量的存储，这里可以看一下下面代码中的注释： 12345678910111213141516171819202122232425public class NewThreadWithStackSize &#123; /** * 注意这里不是局部变量，所以这里的int i是放入方法区的 */ private int i = 0; /** * bytes这个变量存放在方法区中，里面存放的是对象在堆内存中的地址 */ private byte[] bytes = new byte[1024]; private static int count = 0; public static void main(String[] args) &#123; // main函数也是一个线程 // create a thread by jvm named 'main' and 创建一个虚拟机栈 // 局部变量 放入局部变量表中 int j = 0; // arr在局部变量表中，对象还是放入堆内存中 int[] arr = new int[1024]; &#125;&#125; 栈帧的结构： 这里可以做一个栈溢出的的例子，来为一个线程分配固定栈空间的大小，看看大概操作栈的次数（这里只是一个大概的数值） 1234567891011121314151617181920212223242526272829public class NewThreadWithStackSize2 &#123; private static int count = 0; public static void main(String[] args) &#123; /** * 指定stackSize的new Thread构造函数 */ Thread thread = new Thread(null, new Runnable() &#123; @Override public void run() &#123; try &#123; add(1); &#125; catch (Error r) &#123; r.printStackTrace(); System.out.println(count); &#125; &#125; private void add(int i) &#123; count ++; add(i+1); &#125; &#125;, "test-stackSize", 1&lt;&lt;23); // 1 右移23位 大概是8mb 给当前线程thread分配了8m的stackSize 进行递归栈溢出 thread.start(); &#125;&#125; 可以看到count的数值是： 我们可以知道：构造Thread的时候传入stacksize表示该线程占用的stack大小，如果没有指定stacksize的大小，默认是0，0代表着会忽略该参数，该参数会被JNI函数去调用。需要注意：该参数有一些平台有效，有些平台则无效。可以通过jvm参数 -Xss10m 来设置stacksize的大小]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——观察者模式]]></title>
    <url>%2Fblog%2F2018%2F12%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[观察者模式观察者模式也是我们经常会用到的设计模式之一，这里用一个气象站的一些数据变化通知气象板为例去记录一下观察者设计模式，值得一提的是java中提供了观察者模式的接口和类。 demo一个气象站通知气象板的小demo，气象站提供温度、气压、湿度的数据给一些气象板提供数据，当气象站发生变化了之后，要通知订阅气象站数据的气象板数据变更。 一般方案在气温变化的气象站中加入气象板对象，在数据变化时，去调用气象板对象的update方法。 气象站WeatherData类中，定义了看板类成员变量，在dataChange方法中调用了该气象板的update方法来动态的变更气象板的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142@Getter@Setterpublic class WeatherData &#123; /** * 温度 */ private float temperature; /** * 湿度 */ private float humidity; /** * 气压 */ private float pressure; // 定义进来模拟的当天的看板 在构造函数中进行初始化 private CurrentConditions currentConditions; public WeatherData(CurrentConditions currentConditions) &#123; this.currentConditions = currentConditions; &#125; private void dataChange() &#123; currentConditions.update(getTemperature(), getPressure(), getHumidity()); &#125; /** * 模拟数据变化过程 */ public void setData(float temperature, float pressure, float humidity) &#123; setTemperature(temperature); setPressure(pressure); setHumidity(humidity); dataChange(); &#125;&#125; 模拟的气象站CurrentConditions类中，提供了update方法去修改了自己类中的成员变量。 1234567891011121314151617181920212223242526272829@ToStringpublic class CurrentConditions &#123; private float currentTemperature; private float currentPressure; private float currentHumidity; /** * 进行更新看板中的数据 并且打印 * @param currentTemperature * @param currentPressure * @param currentHumidity */ public void update(float currentTemperature, float currentPressure, float currentHumidity) &#123; this.currentTemperature = currentTemperature; this.currentPressure = currentPressure; this.currentHumidity = currentHumidity; display(); &#125; public void display() &#123; System.out.println("*** Today ***" + toString()); &#125;&#125; 运行主方法： 1234567891011121314151617181920212223public static void main(String[] args) &#123; // 新建一个 当天天气的公告板 CurrentConditions currentConditions = new CurrentConditions(); WeatherData weatherData = new WeatherData(currentConditions); // 模拟气象变化 weatherData.setData(300f, 100f, 22f); // 再次变化 weatherData.setData(200f, 111f, 222f); /** * 但是可以想到这种方式是只有一种当天天气的公告板 * 但是如果有很多公告板 再接入的时候就要在WeatherData中定义这个公告板，在changeData中调用update * 扩展性很差 * * 要用观察值模式去增强这个demo的观察者，把变得部分做抽象和接口设计 * 看use_observer package */&#125; 可以看到运行结果： 12*** Today ***CurrentConditions(currentTemperature=300.0, currentPressure=100.0, currentHumidity=22.0)*** Today ***CurrentConditions(currentTemperature=200.0, currentPressure=111.0, currentHumidity=222.0) 这种方案的弊端： 拓展性比较差，这只是一个气象看板的情况，如果是多个气象看板，那么需要耦合在WeatherData类中。 必须要知道每个订阅气象站的看板对象的update方法参数，这个也要去耦合多个逻辑。 观察者模式改进这里简单描述下观察者模式的定义： 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。被依赖的对象为Subject，依赖的对象为Observer，Subject通知Observer变化 。 那么在我们的demo场景中，我们要去分析不变的部分和变的部分。 变的部分：是一对多关系的维护，气象板可能增加并且减少，并且每个订阅气象站数据的气象板对象去更新的参数和方式也不一样。 不变的部分：是气象站中对观察者们的注册和移除方法，并且要对每个观察者去通知更新其数据的接口；观察者们要去提供update接口。这些不变的部分是可以抽象成接口和其中的成员方法的。 方案定义主题接口和观察者接口： 订阅的主题Subject接口，这个接口中有观察者的订阅和观察者的移除方法，同时也有通知所有的观察者的方法。 12345678910111213141516171819public interface Subject &#123; /** * 观察者订阅接口 * @param observer */ void registerObserver(Observer observer); /** * 移除观察者方法 * @param observer */ void removerObserver(Observer observer); /** * 通知所有的观察者方法 */ void notifyObservers();&#125; 观察者要实现的接口Observer： 这个接口中定义了update的行为方法，这里是简单写了去主动传入关心的三个数据 1234public interface Observer &#123; void update(Float currentTemperature, Float humidity, Float pressure);&#125; 再去看相应的气象站和气象看板的实现，这里气象站应该去实现主题Subject接口，而气象看板应该实现Observer接口提供自己的更新逻辑。 气象站WeatherData类，里面使用ArrayList&lt;Observer&gt;去定义了观察者的集合，此外也有实现了循环去通知观察者和删除观察者的接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Datapublic class WeatherData implements Subject &#123; /** * 温度 */ private float temperature; /** * 湿度 */ private float humidity; /** * 气压 */ private float pressure; /** * 观察者集合 */ private ArrayList&lt;Observer&gt; observerArrayList; @Override public void registerObserver(Observer observer) &#123; observerArrayList.add(observer); &#125; @Override public void removerObserver(Observer observer) &#123; if (observerArrayList.contains(observer)) &#123; observerArrayList.remove(observer); &#125; &#125; @Override public void notifyObservers() &#123; // 这里的通知 参数是写死的三个 拓展性较差 // java内置的观察者中有拓展参数 动态去取的 // 循环观察者去更新 observerArrayList.forEach(e -&gt; e.update(getTemperature(), getHumidity(), getPressure())); &#125; /** * 模拟参数的变化 */ public void dataChange(float temperature, float humidity, float pressure) &#123; setTemperature(temperature); setHumidity(humidity); setPressure(pressure); // 这里去通知所有的观察者即可 notifyObservers(); &#125;&#125; 这里去定义两个气象看板实现Observer接口，一个是CurrentConditions，一个是ForcastConditions，这里简单模拟就是在update中输出的字符串不相同来模拟不同的任务。 CurrentConditions： 1234567891011121314151617181920212223@Data@ToStringpublic class CurrentConditions implements Observer&#123; private float currentTemperature; private float currentPressure; private float currentHumidity; @Override public void update(Float currentTemperature, Float humidity, Float pressure) &#123; this.currentHumidity = humidity; this.currentPressure = pressure; this.currentTemperature = currentTemperature; display(); &#125; public void display() &#123; System.out.println("*** Today ***" + toString()); &#125;&#125; ForcastConditions: 1234567891011121314151617181920212223@Data@ToStringpublic class ForcastConditions implements Observer &#123; private float currentTemperature; private float currentPressure; private float currentHumidity; @Override public void update(Float temperature, Float humidity, Float pressure) &#123; this.currentHumidity = humidity; this.currentPressure = pressure; this.currentTemperature = temperature; display(); &#125; public void display() &#123; System.out.println("*** Forcast ***" + toString()); &#125;&#125; 在main中运行一下看一下效果： 1234567891011121314151617181920212223242526272829303132333435363738/** * 使用观察者模式增强扩展性的demo * 观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为subject，依赖的对象为Observer，Subject通知Observer变化。拥有比较强的拓展性 * * * @author 夸克 * @date 2018/12/11 01:02 */public class Main &#123; public static void main(String[] args) &#123; // 两个气象看板 去 订阅天气的变化 Observer cuerrent = new CurrentConditions(); Observer forcast = new ForcastConditions(); // 两个观察者订阅主题 WeatherData weatherData = new WeatherData(); ArrayList&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;()&#123;&#123; add(cuerrent); add(forcast); &#125;&#125;; weatherData.setObserverArrayList(list); // 模拟天气变化 System.out.println("=============天气变化1============="); weatherData.dataChange(111f, 222f, 333f); System.out.println("=============天气变化2============="); weatherData.dataChange(333f, 444f, 555f); System.out.println("=============添加一个观察者============="); weatherData.registerObserver(new ForcastConditions()); // 再次模拟天气变化 weatherData.dataChange(555f, 666f, 777f); &#125;&#125; 结果如下 12345678910=============天气变化1=============*** Today ***CurrentConditions(currentTemperature=111.0, currentPressure=333.0, currentHumidity=222.0)*** Forcast ***ForcastConditions(currentTemperature=111.0, currentPressure=333.0, currentHumidity=222.0)=============天气变化2=============*** Today ***CurrentConditions(currentTemperature=333.0, currentPressure=555.0, currentHumidity=444.0)*** Forcast ***ForcastConditions(currentTemperature=333.0, currentPressure=555.0, currentHumidity=444.0)=============添加一个观察者=============*** Today ***CurrentConditions(currentTemperature=555.0, currentPressure=777.0, currentHumidity=666.0)*** Forcast ***ForcastConditions(currentTemperature=555.0, currentPressure=777.0, currentHumidity=666.0)*** Forcast ***ForcastConditions(currentTemperature=555.0, currentPressure=777.0, currentHumidity=666.0) java内置的观察者模式jdk中有内置的观察者模式，是java.util.Observable类，这个要注意并不是对应着上边自定义观察者模式中的Observer接口，而是对应着我们自定义的主题Subject接口，并且这里去设计成了类。而java中也是用Observer接口去对应观察者模式的Observer接口。 可以先看下java内置的Observer接口：可以看到也是去定义了一个update方法，然后传入了Observable类，也就是订阅的主题，还有就是一个Object的参数，其实就是update的更新数据，这里要求封装成一个Object。 123456789101112131415161718192021/** * A class can implement the &lt;code&gt;Observer&lt;/code&gt; interface when it * wants to be informed of changes in observable objects. * * @author Chris Warth * @see java.util.Observable * @since JDK1.0 */public interface Observer &#123; /** * This method is called whenever the observed object is changed. An * application calls an &lt;tt&gt;Observable&lt;/tt&gt; object's * &lt;code&gt;notifyObservers&lt;/code&gt; method to have all the object's * observers notified of the change. * * @param o the observable object. * @param arg an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt; * method. */ void update(Observable o, Object arg);&#125; 再来看下Subject也就有Observable类： 定义了两个成员变量，changed是标识一个观察者们是否变化的状态，而obs指的就是观察者的集合，这里是用Vector存储的。 12private boolean changed = false;private Vector&lt;Observer&gt; obs; 定义的添加和删除观察者都是同步的：（addElement和removeElement就是对Vector的操作添加元素和删除元素的操作，这里不去赘述） 1234567891011public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125;&#125;public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; 通知观察者的方法也可以看到分析了存在竞争条件的情况： 一种是新注册的观察者会错过主题进行的通知，另一种是未注册的观察者会被误通知，所以这里同步代码块中，判断了changed这个状态，只有当changed为true才将vector中存储的观察者赋给arrLocal变量；并且在clearChanged方法中也同步清除了changed为true这个状态，这个是为了表示该对象已不可改。这样去广播通知的时候就不用去同步代码块中执行。 1234567891011121314151617181920212223242526272829303132333435public void notifyObservers(Object arg) &#123; /* * a temporary array buffer, used as a snapshot of the state of * current Observers. */ Object[] arrLocal; synchronized (this) &#123; /* We don't want the Observer doing callbacks into * arbitrary code while holding its own Monitor. * The code where we extract each Observable from * the Vector and store the state of the Observer * needs synchronization, but notifying observers * does not (should not). The worst result of any * potential race-condition here is that: * 1) a newly-added Observer will miss a * notification in progress * 2) a recently unregistered Observer will be * wrongly notified when it doesn't care */ if (!changed) return; arrLocal = obs.toArray(); clearChanged(); &#125; for (int i = arrLocal.length-1; i&gt;=0; i--) ((Observer)arrLocal[i]).update(this, arg);&#125; protected synchronized void clearChanged() &#123; changed = false; &#125; 在这个类中提供了一些同步方法，比如判断changed是否发生变化、比如返回当前观察者的数量。这里不去赘述。 jdk内置的Observable类中还提供了没有参数的notifyObservers方法，这里相当于调用了notifyObservers(null)，这里就可以理解为有些场景是关心Subject变化但是不需要Subject传入参数，所有提供了这个方法。 使用java内置观察者模式改造气象站demo这里就可以让气象站去继承Observable类，即观察者模式中的主题，去重写Observable类中的一些方法。 同时各个气象看板要去实现jdk内置的Observer接口和实现其中的update方法。这里要把要更新的数据做成一个类，来适配update接口。 气象站WeatherData类，可以看到这里调用了父类的setChanged方法和notifyObservers方法，这里由刚才看到notify通知的源码知道要注意设置changed参数为true，这样才会去广播数据变更给观察者们。所以这里在数据变更的方法之前调用了设置changed参数为true的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Datapublic class WeatherData extends Observable &#123; /** * 温度 */ private float temperature; /** * 湿度 */ private float humidity; /** * 气压 */ private float pressure; private void dataChange() &#123; // 使用jdk内置Subject 即Observable类，通知观察者们的时候要设置changed为true super.setChanged(); super.notifyObservers(new Data(getTemperature(), getHumidity(), getPressure())); &#125; /** * 模拟数据变化过程 */ public void setData(float temperature, float pressure, float humidity) &#123; setTemperature(temperature); setPressure(pressure); setHumidity(humidity); dataChange(); &#125; /** * 通知观察者的数据类 这里要是适配JDK内置的Observer接口中的update方法 */ @AllArgsConstructor public class Data&#123; /** * 温度 */ private float temperature; /** * 湿度 */ private float humidity; /** * 气压 */ private float pressure; &#125;&#125; 再来看两个气象看板的类，这里是实现了update方法，转为了数据类去更新数据。 12345678910111213141516171819202122232425262728293031323334@Data@ToStringpublic class CurrentConditions implements Observer &#123; /** * 温度 */ private float temperature; /** * 湿度 */ private float humidity; /** * 气压 */ private float pressure; @Override public void update(Observable o, Object arg) &#123; WeatherData.Data data = (WeatherData.Data) arg; setTemperature(data.getTemperature()); setHumidity(data.getHumidity()); setPressure(data.getPressure()); display(); &#125; public void display() &#123; System.out.println("*** Today ***" + toString()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536@Data@ToStringpublic class ForcastConditions implements Observer &#123; /** * 温度 */ private float temperature; /** * 湿度 */ private float humidity; /** * 气压 */ private float pressure; @Override public void update(Observable o, Object arg) &#123; // TODO 这里还可以对Observable 进行一个筛选和过滤的逻辑 WeatherData.Data data = (WeatherData.Data) arg; setTemperature(data.getTemperature()); setHumidity(data.getHumidity()); setPressure(data.getPressure()); display(); &#125; public void display() &#123; System.out.println("*** forcast ***" + toString()); &#125;&#125; 这里去测试下： 123456789101112131415161718public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); // 两个观察者，使用java内置观察者模式 通知顺序和注册顺序是相反的 CurrentConditions currentConditions = new CurrentConditions(); weatherData.addObserver(currentConditions); weatherData.addObserver(new ForcastConditions()); // 这时模拟气候变动 weatherData.setData(111f, 222f, 333f); System.out.println("移除一个观察者"); // 移除一个观察者 注意这里要将上面同一个观察者对象 作为移除参数 weatherData.deleteObserver(currentConditions); weatherData.setData(444f, 555f, 666f);&#125; 可以看到输出结果： 123456*** forcast ***ForcastConditions(temperature=111.0, humidity=333.0, pressure=222.0)*** Today ***CurrentConditions(temperature=111.0, humidity=333.0, pressure=222.0)移除一个观察者*** forcast ***ForcastConditions(temperature=444.0, humidity=666.0, pressure=555.0)Process finished with exit code 0]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test多个设备使用hexo]]></title>
    <url>%2Fblog%2F2018%2F12%2F24%2Ftest%E5%A4%9A%E4%B8%AA%E8%AE%BE%E5%A4%87%E4%BD%BF%E7%94%A8hexo%2F</url>
    <content type="text"><![CDATA[背景hexo是支持多设备去写你的博客的，这里参考的是这个资料： hexo多设备]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合中的深拷贝]]></title>
    <url>%2Fblog%2F2018%2F12%2F19%2F%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[深拷贝与浅拷贝对对象的深拷贝和浅拷贝我们并不陌生。 （1）浅拷贝： 在浅拷贝中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅拷贝中，当对象被复制时只复制它本身和其他包含的值类型的成员变量，而引用类型的成员对象并没有复制。在Java中，通过覆盖Object类的clone()方法可以实现浅拷贝。 （2）深拷贝: 在深拷贝中，无论原型对象的成员变量是值对象还是引用类型，都将复制一份给克隆对象，深拷贝将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。在Java中，如果要实现深拷贝，可以通过覆盖Object类的clone()方法实现，也可以通过序列化(Serialization)等方式来实现。（当然如果引用类型里面还包含很多引用类型，或者内层引用类型的类里面又包含引用类型，使用clone方法就会很麻烦。这时我们可以用序列化的方式实现对象的深克隆。） 这里肯定有些朋友注意到Cloneable接口和Serializable接口，这两个接口其实都是java中的标记型接口，其中都没有任何方法的定义，其实就是告诉jre这些接口的实现类是否有某个功能，是否支持克隆，是否支持序列化。 Object类中的clone()方法可以看到这个方法在Object类中是protected的。可与看看它的方法的源码注释： 12345678910111213/** * Creates and returns a copy of this object. The precise meaning * of "copy" may depend on the class of the object. The general * intent is that, for any object &#123;@code x&#125;, the expression: * x.clone() != x * will be true, and that the expression: * x.clone().getClass() == x.getClass() * will be &#123;@code true&#125;, but these are not absolute requirements. * While it is typically the case that: * x.clone().equals(x) * will be &#123;@code true&#125;, this is not an absolute requirement. * &lt;p&gt; */ 从注释中我们可以看到： 因为x.clone != x，所以我们可以知道克隆对象将有单独的内存地址分配。 原始对象和克隆对象有相同的类型，但它不是强制的。 原始和克隆对象应该是平等的，equal()方法返回true，但它不是强制的。 同时，可以猜想到clone()方法设置为protected的原因：每个类都去继承了Object方法，但是clone提供的是浅拷贝的功能，我们并不知道要拷贝的原始类中成员都是值对象还是引用对象，如果要在一个类B中使用一个非同包类A的clone对象，并且B没有继承A，那么这时是不能调用A.clone()，因为Object的clone方法是protected的，如果要调用则需要A去重写clone方法，并且把clone方法的可见范围变为B类能访问的可见范围。这样A就可以对自身的成员变量是否存在引用对象去判断到底是提供深拷贝还是浅拷贝克隆方法，从而不会把自己的引用成员变量暴露出去被修改。关于这个详细的解释有篇博客：clone方法为什么是protected的？ 浅拷贝和深拷贝的实现浅拷贝浅拷贝的实现： 实现Cloneable接口（不实现的话在clone方法会抛出ClassNotSupportedException异常）,虽然该接口只是一个标记型接口。 覆盖clone方法，访问修饰符是public。方法中调用supers.clone()方法得到需要的复制对象。(native本地方法，效率还是很高的)。 demo来一个无论学习什么知识都会有的User类，让其实现Cloneable接口且覆盖父类的clone方法 12345678910111213141516171819202122232425262728293031323334public class User implements Cloneable&#123; // Cloneable是一个标记型接口，不实现在进行拷贝的时候会报错 private int number; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; @Override public String toString() &#123; return "User&#123;" + "number=" + number + '&#125;'; &#125; /** * 重写Object的clone方法 * * 改修饰权限符为public * * 直接调用super.clone() 这个native方法进行拷贝对象 */ @Override public User clone() throws CloneNotSupportedException &#123; return (User) super.clone(); &#125;&#125; 测试一下浅拷贝 12345678910111213141516171819202122232425/** * test方法 */public static void main(String[] args) &#123; User user1 = new User(); user1.setNumber(1111); User user2 = null; // 实现浅拷贝 try &#123; user2 = user1.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; if (null != user2) &#123; // 变更浅拷贝出的对象中的成员变量 user2.setNumber(2222);- &#125; System.out.println(user1);// 输出1111，浅拷贝 System.out.println(user2);&#125; 深拷贝在User类中加入一个引用对象Address类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class User implements Cloneable&#123; // Cloneable是一个标记型接口，不实现在进行拷贝的时候会报错 private int number; /** * 引用对象 */ private Address address; public int getNumber() &#123; return number; &#125; public void setNumber(int number) &#123; this.number = number; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public User(int number, Address address) &#123; this.number = number; this.address = address; &#125; @Override public String toString() &#123; return "User&#123;" + "number=" + number + ", address=" + address + '&#125;'; &#125; /** * 覆盖clone方法 * 改为public * * 返回值为user * * @return */ @Override public User clone() &#123; User user = null; try &#123; user = (User) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return user; &#125;&#125; Address类中并没有实现Cloneable接口和覆盖clone方法 123456789101112131415161718192021222324public class Address &#123; private String add; public String getAdd() &#123; return add; &#125; public void setAdd(String add) &#123; this.add = add; &#125; public Address(String add) &#123; this.add = add; &#125; @Override public String toString() &#123; return "Address&#123;" + "add='" + add + '\'' + '&#125;'; &#125;&#125; 这时候测试 12345678910111213141516171819202122public static void main(String[] args) &#123; Address address = new Address("1111"); User user1 = new User(1111, address); User user2 = user1.clone(); System.out.println(user1); // 都输出1111 System.out.println(user2); // 修改user2的成员变量 address.setAdd("2222"); // 因为现在还是浅拷贝 user1 和 user2中的值还指向堆内存中同一个address对象 System.out.println(user1); System.out.println(user2);&#125;// 返回结果User&#123;number=1111, address=Address&#123;add='2222'&#125;&#125;User&#123;number=1111, address=Address&#123;add='2222'&#125;&#125; 可以看到当改变add的值的时候，user1和user2中的address对象都发生了改变，这里是因为user2只是user1的浅拷贝生成的对象，user2对象中的address成员变量只是复制了user1中的address变量的引用， 并没有将user2中的address对象指向另一块Address对象。 这里可以去改造下，Address对象要实现Cloneable接口并且覆盖clone方法，并且User对象中的clone方法也要定义user对象中的address成员变量的拷贝 Address中的clone 123456789101112@Overridepublic Address clone() &#123; // 实现clone方法 Address address = null; try &#123; address = (Address) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return address;&#125; User中的clone： 123456789101112131415 */@Overridepublic User clone() &#123; User user = null; try &#123; user = (User) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; // 对引用类型的成员变量进行clone user.address = address.clone(); return user;&#125; 这样发现运行的结果： 12345User&#123;number=1111, address=Address&#123;add=&apos;1111&apos;&#125;&#125;User&#123;number=1111, address=Address&#123;add=&apos;1111&apos;&#125;&#125;====================变更了address====================User&#123;number=1111, address=Address&#123;add=&apos;2222&apos;&#125;&#125;User&#123;number=1111, address=Address&#123;add=&apos;1111&apos;&#125;&#125; 实现深拷贝的方法重写clone方法在上面的测试中，我们可以知道重写clone可以实现深拷贝，但是当我们遇到成员变量是一个嵌套对象的时候也要求内层嵌套对象也要重写clone方法，这样比较麻烦，我们可以采用序列化的方式去做深拷贝 序列化方式序列化方式下，我们需要让需要拷贝的对象类实现序列化接口，然后通过流或者Json等序列化工具去深拷贝一个对象。 一个基于流的深拷贝工具类这里提供一个基于流的深拷贝工具类，这里场景是根据 1234567891011121314151617181920212223242526272829303132333435363738@SuppressWarnings("unchecked")@Slf4jpublic class DeepCopyUtil &#123; /** * 对集合进行深拷贝 * * @param src * @param &lt;T&gt; * @return */ public @Nullable static &lt;T&gt; Collection&lt;T&gt; deepCopy(Collection&lt;T&gt; src) &#123; if (CollectionUtils.isEmpty(src)) &#123; return null; &#125; try &#123; ByteArrayOutputStream byteOut = new ByteArrayOutputStream(); ObjectOutputStream out = new ObjectOutputStream(byteOut); out.writeObject(src); ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray()); ObjectInputStream in = new ObjectInputStream(byteIn); return (Collection&lt;T&gt;) in.readObject(); &#125; catch (ClassNotFoundException | IOException e) &#123; log.warn("deep copy fail, src=&#123;&#125; ", JSON.toJSONString(src), e); return null; &#125; &#125;&#125; 其实还是比较建议直接用FastJson或者其他序列化工具去序列化来实现深拷贝。 github该部分代码：https://github.com/zhanglijun1217/java8/tree/master/src/deep_and_shallow_copy]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java集合类的一些总结——Arrays.asList和Guava操作集合]]></title>
    <url>%2Fblog%2F2018%2F12%2F15%2Fjava%E9%9B%86%E5%90%88%E7%B1%BB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94Arrays-asList%E5%92%8C%E5%B9%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[使用背景总结一下最近项目中使用到集合的两个点，一个是Arrays.asList这个方法使用的坑，另一个是利用Guava的Sets工具类去求并交集。 使用总结Arrays.asList的坑先上结论： Arrays.asList这个方法不适用于基本类型：byte,short,int,long,float,double,boolean 该方法将数组和列表动态链接起来，当其中一个更新后，另一个也会更新 不支持add和remove方法（1）首先对于第一点，这个方法不适用于基本类型，并不是不能用于基本类型，看一下下面的代码：1234567public static void main(String[] args) &#123; int[] int_array = &#123;1, 2, 3&#125;; List&lt;int[]&gt; ints = Arrays.asList(int_array); // 对于基本类型，会打印一个元素结果 System.out.println(ints);&#125; 输出：1[[I@610455d6] 从Arrays.asList返回List的泛型可知，这个工具方法将基本类型的数组只转成了一个元素的列表。因为在Arrays.asList中，该方法接受一个变长参数，一般可以看做数组参数，但是因为int[]本身就是一个类型，所以data变量作为参数传递时，编译器认为只传了一个变量，这个变量的类型是int数组，所以会这样。基本类型是不能作为泛型的参数，按道理应该使用包装类型，这里没有报错是因为数组是可以泛型化的，所以在转换后list中有一个类型为int[]的数组。值得注意的是，如果这时打印出其中的class，会返回class[I。因为jvm不可能输出int[]对应的array类型，array属于java.lang.reflect包，通过反射访问数组这个类，编译时生成的这个class值。（2）对于第二点，我们可以尝试改变数组中的值时，可以看看对应list中的值：1234567891011121314String[] string_array = &#123;"aa", "bb", "cc"&#125;; List&lt;String&gt; stringList = Arrays.asList(string_array); System.out.println("============改变数组前============"); System.out.println(stringList); // 改变数组 string_array[1] = "change"; System.out.println("============改变数组后============"); System.out.println(stringList); // 改变list stringList.set(1, "change2"); System.out.println("============改变list后============"); System.out.println(string_array[1]); 输出结果：123456============改变数组前============[aa, bb, cc]============改变数组后============[aa, change, cc]============改变list后============change2 这个通过源码很好理解，可以看一下asList的源码：12345@SafeVarargs @SuppressWarnings("varargs") public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; new ArrayList构造函数代码：1234private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; 从源码中得到asList就是将数组作为返回的List的实际引用，即List中的数组就是要转成list的数组，所以当更改数组中的值时，list中的值也会变化，list列表中的值变更也相当于变更了其中的数组，也就是源数据数组。这就是所谓的链接在一起。Arrays.asList体现的是适配器模式，只是转换接口（array到list），后台的数据仍是数组。（3）第三点是数组转换之后的List是不支持remove和add方法的。这里说的不支持，是调用add或者remove方法之后会抛出一个异常 java.lang.UnsupportedOperationException。一开始感到奇怪，ArrayList为什么不支持add和remove方法？这里去看了返回的ArrayList的源码，这个ArrayList并不是常用的ArrayList，而是在Arrays中定义的一个内部类：1234567891011private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; ... // 省略一些代码 &#125; 这个内部类虽然继承了AbstractList，但是没有去实现其中的add和remove方法，可以看下AbstractList中定义的默认add方法的实现：123456789101112131415/** * &#123;@inheritDoc&#125; * * &lt;p&gt;This implementation always throws an * &#123;@code UnsupportedOperationException&#125;. * * @throws UnsupportedOperationException &#123;@inheritDoc&#125; * @throws ClassCastException &#123;@inheritDoc&#125; * @throws NullPointerException &#123;@inheritDoc&#125; * @throws IllegalArgumentException &#123;@inheritDoc&#125; * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; throw new UnsupportedOperationException(); &#125; 可以看到如果没有去实现add方法，那么会抛出这个异常，这里因为也叫做ArrayList，所以还是比较容易踩坑。clear、remove方法也是一样的原因。关于Arrays.asList的代码github地址：https://github.com/zhanglijun1217/java8/tree/master/src/Arrays_asList Guava中的Sets工具类求交集近期也去使用了一个求集合交集的场景。这里去简单记录下Guava中的这个用法。1Sets.intersection(set1, set2); 这个方法返回的是一个新的集合去承接传入两个集合的交集的。Guava也提供了对集合操作很多其他方法，比如并集、差集、全集等，这个后面会去总结。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Arrays.asList</tag>
        <tag>集合操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ClassNotFoundException和NoClassDefFoundError]]></title>
    <url>%2Fblog%2F2018%2F12%2F06%2FClassNotFoundException%E5%92%8CNoClassDefFoundError%2F</url>
    <content type="text"><![CDATA[背景极客时间上《Java核心技术36讲》第二讲中提到了一个问题：ClassNotFoundException和NoClassDefFoundError有什么区别？看到这个问题的时候，第一时间想到的就是一个是受检的异常，而另一个是一个Error，但是其实在真正的项目开发中这两个错误都遇到过，都是关于类或者文件jar包找不到的错误，这里去总结下其中的不同。 两者的区别ClassNotFoundException可以看到，ClassNotFound是一个继承自ReflectiveOperationException的受检异常。JDK中的解释是：当应用程序视图使用以下方法通过字符串加载类时，（加载的方法）（1）Class类中的forName()方法（2）ClassLoader类中的findSystemClass方法（3）ClassLoader类中的loadClass方法。但是没有找到具体指定名称的类的定义。这里可以知道当应用程序运行的过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到执行的类，那么就会抛出ClassNotFoundException。一般情况下，当我们使用Class.forName()或者ClassLoader.loadClass()以及使用ClassLoader.findSystemClass()在运行时加载类的时候，如果类没有找到，那么就会导致JVM抛出ClassNotFoundException。最常见的，我们都写过jdbc连接数据库的代码，我们都会用到Class.forName()去加载JDBC的驱动，如果我们没有将驱动放到应用下的classPath，那么会导致抛出异常ClassNotFoundException。 12345678910public static void main(String[] args) &#123; try &#123; Class.forName("aaaaaa"); &#125; catch (ClassNotFoundException e) &#123; System.out.println("发生了ClassNotFoundException"); &#125; &#125; 还有根据类加载器的可见性机制，子类加载器可以看到父类加载器加载的类，而反之则不行。所以当一个类已经被Application类加载器加载过了，然后如果想要使用Extension类加载器加载这个类，将会抛出java.lang.ClassNotFoundException异常。 NoClassDefFoundError看名字这个是一个Error异常，看源码可以看到它是一个继承自LinkageError的Error异常，看官网中的解释是要找的类在编译时期还可以找到，但是在运行java应用的时候找不到了，这比较经常出现在静态块的初始化过程中。JDK官方的解释：当虚拟机或ClassLoader实例在类的定义中加载（作为通用方法调用的一部分或者作为new 表达式创建的新实例的一部分），但是无法找到该类的定义时，抛出此异常。当前执行的类被编译时，所搜索的类定义存在，但无法再找到该定义。从官网的解释中我们可以看到如果编译了一个类B，在类A中调用，编译完成之后，你又删除B的class文件，运行A的时候那么就会出现这个错误。 总结这里总结一下ClassNotFoundException和NoClassDefFoundError的区别：（1）一个是Exception，受检的异常；而一个是Error。（2）ClassNotFoundException是在动态加载Class的时候调用Class.forName等方法抛出的异常；而NoClassDefFoundError是在编译通过后执行过程中Class找不到导出的错误。（3）ClassNotFoundException是发生在加载内存阶段，加载时从classpath中找不到需要的class就会出现ClassNotFoundException，出现这种错误可能是调用上述的三个方法加载类，也有可能是已经被一个类加载器加载过的类又被另一个类加载器加载；而NoClassDefFoundError是链接阶段从内存找不到需要的class才会出现，比如maven项目有的时候打包问题会引起这个error报错，这个时候要把仓库中的包删掉重新去拉一下包。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java平台</tag>
        <tag>解释执行、编译执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java平台与java是解释执行的正确性]]></title>
    <url>%2Fblog%2F2018%2F11%2F30%2Fjava%E5%B9%B3%E5%8F%B0%E4%B8%8Ejava%E6%98%AF%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7%2F</url>
    <content type="text"><![CDATA[背景最近看了一点点极客时间上的《Java核心技术36讲》，打算把一些自己感兴趣或者不知道的点总结到博客中，方便对一些知识有一些整理和拾遗。 Java平台性的理解java本身是一种面向对象的语言，有两个特征，一是“write once, run anywhere”，能够非常容易的获取跨平台的能力；另外就是垃圾手机机制，Java通过垃圾收集器(Garbage Collector)回收分配内存。 我们会接触到JRE和JDK。其中JRE是Java Runtime Environment，JDK是Java Development Kit。JRE是java运行环境，包含了JVM和java类库，以及一些模块等。而JDK可以看做是JRE一个超集，提供了更多工具，比如编译器、各种诊断工具、安全工具等。 对于Java平台的理解，可以从两个方面去谈一下。第一个方面是Java语言的特性，包括泛型、集合类、java8中的lambda特性、基础类库、IO/NIO、网络、并发、安全等，这个系统化的去总结一下，肯定能对java平台有更深的理解。另一方面可以去理解JVM中的一些概念和机制，比如Java的类加载机制，JDK中的Class-Loader，例如Bootstrap、Application和Extension Class-loader；类加载的过程：加载、验证、链接和初始化；自定义Class-Loader等；还有java的内存模型，堆、栈、方法区等内存在程序运行时的分配；垃圾回收的基本原理，常见的垃圾回收器，如SerialGC、Parallel GC、CMS、G1等，对于适用于什么样的工作负载也要去有深入的理解。 对于java是解释执行的理解，这个说法是不太准确的。我们写的java代码，首先是通过javac编译成为字节码（byteCode），然后在运行时，通过JVM内嵌的解释器将字节码转换成为最终的机器码。但是存在常见的JIT(Just-In-Time)编译器，也就是说的动态（及时）编译器，JIT能够在运行时将热点代码编译成机器码，这种情况部分热点代码就是属于编译执行，而不是解释执行了。这里说的Java中的编译不同于C中的编译，javac的编译，是把Java代码生成.class字节码，而不是机器直接运行的机器码，Java通过字节码和内嵌虚拟机的这种机制，屏蔽了操作系统和硬件的细节，促使了跨平台性。 在运行时，JVM会通过类加载器（Class-loader）加载字节码，解释或者编译运行。比如JDK8版本中，实际上是采用的解释和编译混合的模式，即混合模型（-Xmixed）。在运行在server模式的JVM，会进行上万次调用以收集足够的信息进行高效的编译，而client模式这个门限是1500次。Oracle HotSpot JVM内置了两个不同的JIT compliers，C1对应之前说的Client模式，使用于对于启动速度敏感的应用，比如普通Java应用；C2对应server模式，这种JIT编译优化适用于长时间运行的服务器端应用设计的。默认是采用所谓的分层编译。另外，在JDK9中引入了AOT特性，所谓AOT（Ahead-of-Time Compilation）就是直接将字节码编译成机器码，避免了JIT预热的一些开销，jdk9中也加入了新的jaotc工具，可以运用jaotc命令使某个类或者模块编译成为AOT库。 JVM启动时，可以指定不同的参数对运行模式进行选择。比如指定”-Xint”，就是告诉JVM只进行解释执行，不对代码进行编译，这种模式相当于直接抛弃了JIT带来的性能优化。与其相对应的，还有一个“-Xcomp”参数，这是告诉JVM关闭解释器，不再进行解释执行。那么这种是不是就会很高效呢？其实不然，这种模式会导致JVM的启动变得很慢。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java平台</tag>
        <tag>解释执行、编译执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——并发基础：守护线程和非守护线程]]></title>
    <url>%2Fblog%2F2018%2F11%2F26%2F%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%9D%9E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言最近在复习的时候，发现一个运行线程池拒绝策略demo中的main方法在运行了之后，进程并没有关闭。看了jconsole线程池中的线程都处于waiting状态。这里是跟我设置线程池的线程工厂中的设置线程是否为后台线程有关。 后台线程和非后台线程后台线程，也叫守护线程，指的是在程序运行的时候后台提供一种通用服务的线程，比如jvm里垃圾回收线程，这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要有任何非守护线程在运行，程序就不会终止。 守护线程和非守护线程的区别：在于jvm的离开：如果用户线程（非守护线程）已经全部退出运行了，只剩下守护线程存在，那么虚拟机也就退出了。因为没了被守护者，守护线程也就没有工作可做了。 设置守护线程是通过调用Thread对象的setDaemon(true)方法来实现的。在使用守护线程的时候需要注意以下几点： （1）thread.setDeaemon(true)必须在thread.start()之前设置，否则会报错IllegalThreadStateException （2）在Daemon线程中产生的线程也是Daemon的。 （3）守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生终端。 不退出程序的代码这里在main方法结束之后不能正常退出的代码是测试了线程池两种抛出拒绝策略的场景： （1）线程池处于SHUTDOWN状态时，再提交新的任务到线程池 （2）线程池中所有的线程都处于运行状态，并且阻塞队列已满，这时再去提交新的线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class ThreadPoolExecutorRejectNewTaskDemo &#123; /** * 线程池的最大容量 */ private static final int MAX_POOL_SIZE = 3; /** * 阻塞队列的容量 */ private static final int QUEUE_CAPACITY = 2; /** * 非核心线程处于空闲状态的最长时间 */ private static final int KEEP_ALIVE_TIME = 1; /** * 线程池对象 注意这里传入的是默认的拒绝策略 也就是AbortPolicy */ private static final ThreadPoolExecutor threadPool = new ThreadPoolExecutor(MAX_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new LinkedBlockingDeque&lt;&gt;(QUEUE_CAPACITY), new MyThreadFactory("task-reject")); public static void main(String[] args) &#123;// shutdownThreadPoolToRejectNewTask(); fullQueueThreadPoolRejectNewTask(); &#125; /** * 模拟线程池被关闭之后， 继续向其中提交新任务被拒绝的场景 */ private static void shutdownThreadPoolToRejectNewTask() &#123; MyRunnable runnable = new MyRunnable(); // 先提交 MAX_POOL_SIZE - 1个任务，此时线程池未满 for (int i=0; i &lt; MAX_POOL_SIZE - 1; i++) &#123; System.out.println("提交任务 " + i); threadPool.submit(runnable); &#125; // 在线程池未满的情况下关闭线程池 threadPool.shutdown(); if (threadPool.isShutdown()) &#123; System.out.println("提交任务" + MAX_POOL_SIZE); // 在线程池未满 但却关闭的情况下去提交任务 此时会拒绝 threadPool.submit(runnable); &#125; &#125; /** * 模拟线程池中线程数都在运行并且阻塞队列已满 */ private static void fullQueueThreadPoolRejectNewTask() &#123; MyRunnable myRunnable = new MyRunnable(); // 提交 MAX_POOL_SIZE + QUEUE_SIZE 个任务 使得线程池线程都在执行任务并且阻塞队列已满 for (int i = 0; i &lt; MAX_POOL_SIZE + QUEUE_CAPACITY; i++) &#123; System.out.println("提交任务 " + i); threadPool.submit(myRunnable); &#125; // 此时再去往其中添加 任务 if (threadPool.getActiveCount() == MAX_POOL_SIZE &amp;&amp; threadPool.getQueue().size() == QUEUE_CAPACITY) &#123; threadPool.submit(myRunnable); &#125; &#125; /** * 自定义线程工厂类 */ private static class MyThreadFactory implements ThreadFactory &#123; /** * namePrefix --&gt; 线程名字中的计数 */ private static Map&lt;String, AtomicInteger&gt; THREAD_ID_TABLE = new ConcurrentHashMap&lt;&gt;(); /** * 线程名称前缀 */ private String namePrefix; /** * 是否后台线程 */ private boolean isDamon; public MyThreadFactory(String namePrefix) &#123; this(namePrefix, false); &#125; public MyThreadFactory(String namePrefix, boolean isDamon) &#123; this.namePrefix = namePrefix; this.isDamon = isDamon; &#125; @Override public Thread newThread(Runnable r) &#123; String threadName = namePrefix + "-" + generateThreadId(this.namePrefix); Thread thread = new Thread(r, threadName); thread.setDaemon(this.isDamon); System.out.println("创建线程" + threadName); return thread; &#125; private static int generateThreadId(String namePrefix) &#123; if (!THREAD_ID_TABLE.containsKey(namePrefix)) &#123; THREAD_ID_TABLE.putIfAbsent(namePrefix, new AtomicInteger(0)); &#125; return THREAD_ID_TABLE.get(namePrefix).getAndIncrement(); &#125; &#125; /** * 向线程池提交的任务 */ private static class MyRunnable implements Runnable &#123; @Override public void run() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 这段代码中创建新线程的线程工厂中设置了线程池中的线程是否为非后台线程，这里设置的是非后台线程，在我们运行main方法之后，即可观察到main方法一直没退出，而线程池中的线程都处于waiting状态。（这里需要设置下不达到拒绝策略的条件，比如去掉达到拒绝策略的条件之后不再提交任务），这里只是复现这个程序不退出的场景。这里只要把新创建的线程设置为后台线程，当main方法结束之后，线程池中的线程都是守护线程，会随着用户线程的结束也被结束掉。 同样的，我们可以看下Executors提供的一些工具线程池，比如Executors.newFixedThreadPool(int nThreads) 它的构造是使用的默认的线程工厂，我们可以看看默认线程工厂中线程的设置是否为后台线程： 1234567891011121314151617181920212223242526272829/** * The default thread factory */static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = "pool-" + poolNumber.getAndIncrement() + "-thread-"; &#125; public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125;&#125; 可以看到默认的线程工厂在创建新的线程的时候也是设置daemon为false，这使得定长线程池中都是用户线程，这些个在主线程结束之后，也会使程序不能退出。]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>守护线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[url拼接参数问题]]></title>
    <url>%2Fblog%2F2018%2F11%2F23%2Furl%E6%8B%BC%E6%8E%A5%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题现象在最近的开发过程中要根据一堆id值去删除ES中的数据，就写了一个脚本接口，传入了idList。这里选择的是GET方式的接口，将idList以逗号分隔当做字符串传入当做参数，然后在接口中转换成List类型再对ES进行操作。 脚本代码这个接口中的process是为了控制是否真正执行刷数据的逻辑，在一些刷数据的接口中加入这个参数，可以去在真正去刷数据之前，去看看捞出来的数据是否正确，然后再进行刷数据的逻辑。 1234567891011121314151617181920212223242526272829303132333435363738@GetMapping(value = "/es/fix/removeNotConsumerData")@ResponseBodypublic boolean removeNotConsumerData(@RequestParam(value = "kdtIdList") String kdtIdListString, @RequestParam(value = "process", defaultValue = "false") boolean process) &#123; List&lt;Long&gt; kdtIdList = Arrays.stream(kdtIdListString.split(",")).map(Long::parseLong).collect(Collectors.toList()); log.info("要刷的数据是：&#123;&#125;", JSON.toJSONString(kdtIdList)); if (!process) &#123; return true; &#125; Set&lt;Long&gt; successSet = Sets.newHashSet(); Set&lt;Long&gt; failSet = Sets.newHashSet(); for (Long kdtId : kdtIdList) &#123; try &#123; ESResult esResult = esSyncHelper.deleteDoc(EsConstant.ESV5_TEAM_INDEX, EsConstant.ESV5_TEAM_TYPE, kdtId.toString(), ESResult.class); Thread.sleep(200); if (AppConstant.SUCCESS != esResult.getCode()) &#123; log.warn("刷数据失败,kdtId=&#123;&#125;, msg:&#123;&#125;", kdtId, esResult.getMessage()); failSet.add(kdtId); &#125; else &#123; successSet.add(kdtId); &#125; &#125; catch (Throwable e) &#123; log.warn("刷数据异常, kdtId=&#123;&#125;", kdtId, e); failSet.add(kdtId); &#125; &#125; if (kdtIdList.size() != successSet.size()) &#123; log.warn("有数据删除失败, failSet=&#123;&#125;", JSON.toJSONString(failSet)); return false; &#125; else &#123; return true; &#125;&#125; 这里在机器上进行跑的时候，先去跑了单个id数据，发现是没有问题的。之后就想一把梭去将数据跑完，就把整个id集合数据放入了url要传入的参数之中，这个时候发现出现了问题。 在数据的最后一条id值被截断了，只是去截止到了42122，所以这个会被转为42122存入要刷的id集合中。这个就可能去刷错了数据（所以之前的process参数还是很有用的 = =）。 这里有个比较稳的解决方案是要刷的数据可以把文件放在resource目录下，然后通过读取这个文件的内容直接去去刷数据，这样就不会存在这个问题了。这里去简单记录下这次参数被截断的过程。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>url拼接参数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastJson中的一些用法]]></title>
    <url>%2Fblog%2F2018%2F11%2F21%2FFastJson%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[FastJson中的一些用法总结fastJson在工作过程中经常用到的一个工具类，之前用到的最多的是在输出日志的时候的对java对象输出序列化之后的json字符串，最近在消费消息端也用到了JsonObject这个类的一些功能，做个简单的FastJson功能类的查漏补缺。 JSONObject通过观察fastJson的源码我们可以发现JSONObject是实现了Map&lt;String, Object&gt;接口的，而且其中也定义了一个map字段，在初始化的时候也是根据是否需要有序来初始化为LinkedHashMap或者HashMap。可以说JSONObject就相当于一个Map&lt;String,Object&gt;。 JSONObject.parseObject方法这个方法其实继承的JSON类中的方法，有多个参数的重载，返回JsonObject对象。那么其实就是将json转换成Map接口类型，然后将JSONObject中的map设置值返回的对象。 用法示例： 1JSONObject jsonObject = JSONObject.parseObject(msg); 当然和Json.parseObject一样，也可以在参数中加入Class参数，直接转成对应的类型对象 1TeamES teamES1 = JSONObject.parseObject(msg, TeamES.class); JSONObject.getXxx()方法JSONObject对象既然存在，那么就会提供访问其中一些键值对的访问，其中的键值对就是json字符串对应的键值对。 Object get(Object key) 这个是根据key值获取对应的value，看方法签名就知道这个方法返回的是Object对象。 JSONObject getJSONObject(String key) 这个方法是根据String的key（在使用的时候就是json字符串中的变量名称），再将value转换成对应的JsonObject对象。因为有时候我们json字符串反序列化出来的是一个嵌套对象，所以嵌套内部的json字符串也可以转换成为一个JSONObject对象。当然如果内部就是一个值的对象的时候会调用JSON的toJSON方法返回一个Object。 JSONArray getJSONArray(String key) 有时候key对应的对象是一个数组，那么可以直接转换成一个JSONArray对象，JsonArray对象和JSONObject对象的设计是一样的，实现了List接口并且把list作为一个字段进行使用。 T getObject(String key, Class clazz) 这个方法支持将JSONObject中的值根据传入的key和对应的Class直接转换为对应的T对象，这里T是泛型。同样的这个方法也支持传入Type和TypeReference getXxx(String key) 类似于getBoolean、getDouble、getLong、getBigDecimal等方法就非常明确了，就是根据String的key（变量名称）转换成对应的包装类型或者基本类型的值。这在我们去解析json字符串中的部分键值对比较有用。 在代码中的应用这里根据传入到底是{“KDT_ID”:xxx}还是传入的{“TEAM_ES”:”{…}”}，拿到对应的值，这里就可以应用我们上面提到的JSONObject类对应的方法。 123456789101112131415161718private TeamES convertTeamESFromMap(JSONObject map) &#123; String key = map.keySet().iterator().next(); TeamES teamES = null; switch (key) &#123; case KDT_ID : Long kdtId = map.getLong(KDT_ID); teamES = constructFromDB(kdtId); break; case TEAM_ES : teamES = map.getObject(TEAM_ES, TeamES.class); break; default:break; &#125; return teamES;&#125;]]></content>
      <categories>
        <category>小知识</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8中的LocalDateTime]]></title>
    <url>%2Fblog%2F2018%2F11%2F11%2Fjava8%E4%B8%AD%E7%9A%84LocalDateTime%2F</url>
    <content type="text"><![CDATA[背景最近在项目中遇到了一些时间进行转化的小需求，比如一个时间添加多少天之后，两个时间的比较之类的。这里要去了解一下java8中的新增的时间API–LocalDateTime。 参考博客： 一些用法系统时间12345678910111213141516171819// now方法获取系统时间LocalDate date = LocalDate.now();// getMonth：英文 getMonthValue : 数字System.out.println(date.getYear() + "/" + date.getMonthValue() + "/" + date.getDayOfMonth());LocalTime time = LocalTime.now();System.out.println(time.getHour() + ":" + time.getMinute() + ":" + time.getSecond());// 没有提供 getMiles()方法 可以这样获取mileSystem.out.println(time.get(ChronoField.MILLI_OF_SECOND));// 日期和时间LocalDateTime dateTime = LocalDateTime.now();System.out.println(dateTime.getYear() + "/" + dateTime.getMonthValue() + "/" + dateTime.getDayOfMonth() + " " + dateTime.getHour() + ":" + dateTime.getMinute() + ":" + dateTime.getSecond());// 时区 获取时间戳Clock clock = Clock.systemDefaultZone();System.out.println(clock.millis()); 特定日期12345678910111213141516171819202122// of方法获取特定日期LocalDate myDate = LocalDate.of(2018, 11, 6);System.out.println(myDate.getYear() + "/" + myDate.getMonthValue() + "/" + myDate.getDayOfMonth());// 获取特定日期对应的属性LocalDate independenceDay = LocalDate.of(2018, Month.JUNE, 4);// 获取周几System.out.println(independenceDay.getDayOfWeek());// 构造LocalTimeLocalTime myTime = LocalTime.of(10, 30, 45);System.out.println(myTime.getHour() + ":" + myTime.getMinute() + ":" + myTime.getSecond());// 同样，LocalDateTime也是可以通过of方法创建特定日期LocalDateTime myDateTime = LocalDateTime.of(2018, Month.JUNE, 4, 10, 30, 45);System.out.println(myDateTime.getYear() + "/" + myDateTime.getMonthValue() + "/" + myDateTime.getDayOfMonth()+ " " + myDateTime.getHour() + ":" + myDateTime.getMinute() + ":" + myDateTime.getSecond());// 也提供了LocalDate 和 LocalTime组合而成的LocalDateTimeLocalDateTime myDateTime2 = LocalDateTime.of(myDate, myTime);System.out.println(myDateTime2.getYear() + "/" + myDateTime2.getMonthValue() + "/" + myDateTime2.getDayOfMonth() + " " + myDateTime2.getHour() + ":" + myDateTime2.getMinute() + ":" + myDateTime2.getSecond()); 格式化123456789 */// date --&gt; StringLocalDate formatDate1 = LocalDate.of(2014, 3, 3);String dateString = formatDate1.format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));System.out.println(dateString);// String --&gt; dateLocalDate formatDate2 = LocalDate.parse(dateString, DateTimeFormatter.ofPattern("yyyy/MM/dd"));System.out.println(formatDate2); 日期转换1234567891011// LocalDate --&gt; LocalDateTimeLocalDate changeDate = LocalDate.of(2018, 12, 4);LocalDateTime changeDateTime = changeDate.atTime(10, 20, 30);System.out.println(changeDateTime);// LocalTime --&gt; LocalDateTimeLocalTime changeTime = LocalTime.of(10, 20, 30);LocalDateTime changeDateTime2 = changeTime.atDate(LocalDate.of(2018, 12, 4));System.out.println(changeDateTime2);// LocalDateTime --&gt; LocalDate,LocalTime 有这样的api toLocalDate toLocalTimeSystem.out.println(changeDateTime.toLocalDate());System.out.println(changeDateTime2.toLocalTime()); 日期加减123456789101112LocalDate now = LocalDate.now();// 2天后System.out.println(now.plusDays(2L));// 3天前System.out.println(now.minusDays(3L));// 一年后System.out.println(now.plusYears(1));// 2周前System.out.println(now.minus(2L, ChronoUnit.WEEKS));// 3年2月1天后System.out.println(now.plus(Period.of(3, 2, 1))); 计算间隔123456789LocalDateTime before = LocalDateTime.of(2011, 2, 11, 11, 11, 11);LocalDateTime after = LocalDateTime.of(2014, 2, 11, 11, 11, 11);// Duration 来表示间隔Duration between = Duration.between(before, after);// 间隔的天System.out.println("间隔：" + between.toDays());// 间隔的分钟System.out.println("间隔：" + between.toMinutes()); 日期比较12345LocalDate compareDate1 = LocalDate.of(2011, 1, 1);LocalDate compareDate2 = LocalDate.of(2012, 1, 1);System.out.println(compareDate1.isBefore(compareDate2));int i = compareDate1.compareTo(compareDate2);System.out.println("c1 compareTo c2 is " + i); 和java.util.Date的转换1234567891011121314151617// LocalDateTime --&gt; Instant --&gt; DateLocalDateTime currentLocalDateTime = LocalDateTime.now();Instant instant = currentLocalDateTime.atZone(ZoneId.systemDefault()).toInstant();Date date1 = Date.from(instant);System.out.println(date1);// Date --&gt; Instant --&gt; LocalDateTimeDate date2 = new Date();Instant instant1 = date2.toInstant();LocalDateTime dateTime1 = LocalDateTime.ofInstant(instant1, ZoneId.systemDefault());System.out.println(dateTime1);// Calendar --&gt; Instant --&gt; LocalDateTimeCalendar calendar = Calendar.getInstance();Instant instant2 = calendar.toInstant();LocalDateTime dateTime2 = LocalDateTime.ofInstant(instant2, ZoneId.systemDefault());System.out.println(dateTime2);]]></content>
      <categories>
        <category>Java语法</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot配置jsp]]></title>
    <url>%2Fblog%2F2018%2F10%2F23%2Fspring-boot%E9%85%8D%E7%BD%AEjsp%2F</url>
    <content type="text"><![CDATA[spring-boot中jsp的使用jsp是之前在学习java开发中会学习到的知识，虽然现在公司中虽然使用jsp越来越少，但是spring-boot配置jsp的使用还是应该去记录一下。 相关依赖增加这里要加入一些依赖： 123456789101112131415161718192021&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- jsper渲染引擎 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 内置tomact --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- jstl 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;/dependency&gt; 还要需要注意的是spring-boot默认打包方式jar包的形式，这里要换成war包的方式。 激活传统Servlet web部署springboot1.4版本之后通过实现org.springframework.boot.web.support.SpringBootServletInitializer抽象类中的抽象方法来将启动类添加到souce中 12345678public class JspConfig extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; // source启动类 告知一些静态资源 builder.sources(SpringBootDemoApplication.class); return builder; &#125;&#125; 加入资源目录位置在项目的src/main目录下建立一个webapp文件夹，这个webapp目录下建立WEB-INFO和jsp文件夹，写一个index.jsp文件作为之后的测试页面。 目录： 12345&lt;html&gt;&lt;body&gt;hello, $&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 设置访问资源文件的前缀和后缀在application.properties配置文件中配置访问jsp文件中的prefix和suffix，注意这里这prefix中的开头和结尾的/是不能省略的，否则会访问不到你的资源。 123# 访问jsp资源的前缀和后缀spring.mvc.view.prefix = /WEB-INFO/jsp/spring.mvc.view.suffix = .jsp 写一个test的controller在配置好了之后，写一个controller作为入口去访问这个jsp文件 1234567891011@Controllerpublic class JspController &#123; @RequestMapping(value = "/index") public String index(Model model) &#123; model.addAttribute("message", "zlj"); return "index"; &#125;&#125; 这时候在浏览器中输入localhost:7001/index即可访问到我们返回给index.jsp中message占位符的字符串值。]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>actuator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——ThreadPoolExecutor源码分析（二）]]></title>
    <url>%2Fblog%2F2018%2F10%2F11%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言在上一篇中，我们分析了ThreadPoolExecutor中关键变量ctl，这篇我们继续来看ThreadPoolExecutor中的构造函数及其参数。其中参数的相关解释来源于源码中的相关注释。 构造函数我们可以看到ThreadPoolExecutor有四个构造函数： 他们其实都是调用其中的全参数的构造函数，只不过有一些参数是使用了默认提供的参数。我们可以看一下构造函数： 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 可以看到构造函数现对于参数去进行了校验：（1）corePoolSize必须大于等于0，maximumPoolSize必须大于0，maximumPoolSize必须大于等于corePoolSize，keepAliveTime如果传入了必须大于0。 （2）workQueue、threadFactory、handler不能为空 （3）其中有acc字段的设置是为了设置安全管理器，我们可以自定义我们的安全管理器，否则为从上下文中去拿。可以参考博客：jvm中的安全管理器 构造函数中的参数1.corePoolSizecorePoolSize参数表示线程池中一直存活的线程的最小数量，这些一直存活的线程被称为核心线程，默认情况下，核心线程的最小数量都是整数，除非是调用了allowCoreThreadTimeout()方法并且传入了true，即允许核心线程数在空闲状态下超时而停止（terminated状态），此时如果所有的核心线程先后都因为超时停止，那么线程池中核心线程数会变为0。默认情况下，核心线程是按照需要创建并启动的，也就是说只有当线程池接收到我们提交的任务后，它才会去创建并启动一定的核心线程去执行这些任务。如果没有接收到相关任务，就不会去主动创建核心线程，这种默认的核心线程创建启动方式变主动为被动，类似于观察者模式，有利于降低系统资源的消耗。当然，也可以通过设置preStartCoreThread()或者preStartAllCoreThreads()方法来改变这一机制，使得在新任务还未提交到线程池的时候，线程池就已经创建并启动了一个或所有线程，并让这些核心线程在池中等待任务的到来。 2.maximumPoolSizemaximumPoolSize表示线程池中能容量线程的最大数量，这个值不能超过常量CAPACITY的数值大小，上一篇中也提到了常量CAPACITY的计算方式，这里不去赘述。但是注意一点，当我们提供的工作队列是一个无界的队列，那么这里提供的maximumPoolSize将毫无意义。 当我们通过execute方法提交一个任务的时候： （1）如果线程池处于运行状态（RUNNING）的线程数量小于核心线程数（corePoolSize），那么即使有一些非核心线程处于空闲状态，系统也倾向于新建一个线程来处理这个任务。 （2）如果线程池处于运行状态（RUNNING）的线程数量大于核心线程数（corePoolSize），但又小于maximumPoolSize，那么系统会去判断线程池内部的阻塞队列是否有空位子，如果有空位子，系统会将该任务先存入阻塞队列，如果发现队列中已没有空位子（即队列已满），系统会创建一个新的线程来执行任务。 如果将线程池中的corePoolSize和maximumPoolSize设置为相同的数（也就是说线程池中所有线程都是核心线程），那么该线程池就是一个固定容量的池子。如果将线程池的maximumPoolSize设置为一个非常大的数值（例如Integer.MAX_VALUE），那么相当于允许线程池自己在不同时段调整参与并发的总任务数。通常情况下，都是通过构造函数去初始化corePoolSize和maximumPoolSize，也可以通过set方法调整这两个参数的大小。 3.keepAliveTime &amp; unitkeepAliveTime表示空闲线程处于等待的超时时间，超过该时间后该线程会停止工作。当线程池中总线程数量大于corePoolSize并且allowCoreThreadTimeOut为false时，这些多出来的非核心线程一旦进入空闲等待的状态，就开始计算各自的等待时间，并且这里设定的keepAliveTime的数值作为他们的超时时间，一旦某个非核心线程的等待时间到达了超时时间，该线程就会停止工作（terminated）。而如果不去设置allowCoreThreadTimeout为true，核心线程及时处于空闲状态等待了keepAliveTime，也依然可以继续处于空闲状态等待。 比较好的应用实践： 如果要执行的任务相对较多，并且每个任务执行的时间都比较短，那么可以为keepAliveTime参数设置一个相对较大的值，以提高线程的利用率；如果要执行的任务比较少，线程池使用率比较低，那么可以先将该参数设置为一个较小的参数值，通过超时停机的机制来降低系统资源的开销。 注意一点：构造函数中的参数keepAliveTime和unit这个参数和ThreadPoolExecutor中的keepAliveTime字段的值不一定相等，字段被设置为long型的值，且定义为纳秒的单位，构造函数中的参数还有unit单位，应该是keepAliveTime和unit计算的结果换算为纳秒才和类中的字段是一样的值。 keepAliveTime在构造函数中的类型是long型，这样保证了这个值不会太短。 4.workQueue构造函数中的workQueue是一个BlockIngQueue（阻塞队列）的实例。传入的泛型参数是Runnable，也就是说，workQueue是一个内部元素为Runnable（各种任务，通常是异步的任务）的阻塞队列。阻塞队列是一种类似于”生产者-消费者“模式的队列，当队列已满时如果继续向队列中插入元素，该插入操作将被阻塞一直处于等待状态，直到队列中有元素被移除，才能进行插入操作；当队列为空时如果继续执行元素的删除或者获取操作，也会被阻塞进入等待队列中有新的元素之后才能执行。 workQueue是一个用于保存等待执行的任务阻塞队列，当提交一个新的任务到线程池后，线程池会根据当前池子正在运行的线程数量来判断对这个任务的处理方式： （1）如果线程池中正在运行的线程数少于核心线程数，那么线程池总是倾向于新建一个线程来执行该任务。 （2）如果线程池中正在运行的线程数不少于核心线程数，那么线程池把该任务提交到workQueue中让其先等待 （3）如果线程池中正在运行的线程数不少于核心线程数，并且线程池中的阻塞队列也满了使得该任务入队失败，那么线程池会去判断当前池子中运行的线程数是否已经等于了该线程池允许运行的最大线程数。如果发现已经等于，说明池子已满，那么就会执行拒绝策略；如果发现运行的线程数小于池子允许的最大线程数，那么会创建一个线程（这个线程是非核心线程）来执行该任务。 这其中，队列对于提交的任务一般有三种策略：（1）直接切换 常用的队列是SynchronousQueue（同步队列）,这个队列内部不会存储元素，每一次插入操作都会先进入阻塞状态，一直等到另一个线程执行了队列的删除操作，然后该插入操作才会执行。当提交一个任务到包含这种SynchronousQueue队列的线程池后，线程池会去检测是否有可用的线程来执行任务，如果没有则创建一个新的线程来执行任务而不是将任务存储在任务队列中。”直接切换“的意思是：处理方式由”将该任务暂时存储在阻塞队列中“直接切换为”新建一个线程来处理任务“。这种执行策略适合处理多个有相互依赖关系的任务，因为该策略可以避免这些任务因一个没有及时处理而导致依赖于该任务的其他任务也不能及时处理而造成的锁定结果。因为这种策略的目的是要让几乎每一个新提交的任务都能立即得到处理，所以这种策略通常配合maximumPoolSize是无边际（Integer.MAX_VALUE）的。我们知道的静态工厂方法Executors.newCachedThreadPool()就是使用了这种直接切换的队列。 （2）使用无界队列 不预设队列的容量，队列将使用Integer.MAX_VALUE作为默认容量，例如：基于链表的阻塞队列 LinkedBlockingQueue。使用无界队列使得线程池中能创建的最大线程数等于核心线程数，这样的线程池的maxmumPoolSize的数值将不起任何作用。如果向线程池中提交一个新任务时发现所有的核心线程都处于运行状态，那么该任务将被放入无界队列中等待处理。当要处理的多个任务之间没有相互依赖关系的时候，就适合用这种队列策略来处理这些任务。静态工厂方法Executors.newFixedThreadPool()就使用了这个队列。 （3）使用有界队列 例如使用基于数组的阻塞队列 ArrayBlockingQueue。当要求线程池的最大线程数maximumPoolSize要限定在某个值以内的时候，线程池使用有界队列能降低资源的消耗，但这也使得线程池对线程的调控变得更加困难。因为队列容量和线程池容量都是有限的值，要想使线程处理任务的吞吐量在一个相对合理的范围内，同时又能使线程调度的难度相对较低，并且又尽可能节省系统资源的消耗，那么需要合理的调配这两个值。通常来说，设置较大的队列容量和较小的线程池容量，能够降低系统的资源的消耗（包括CPU的使用率，操作系统的消耗，上下文环境的切换的开销等），但是会降低系统吞吐率。如果发现提交的任务经常频繁的发生阻塞的情况，那么你可以考虑增大线程池的容量，可以通过setMaximumPoolSize()方法来重新设定线程池的容量。而设置较小的队列量时，通常需要将线程池的容量设置大一点，这种情况下，cpu的使用率会比较高，但是如果设置线程池的容量过大的时候，线程调度成了问题，反而使得吞吐率比较低。 5.threadFactory线程工厂，用于创建线程。默认使用Executors.defaultThreadFactory()方法创建线程工厂： 当然我们也可以自己实现ThreadFactory接口去实现我们自己的线程工厂。下边就是可以根据不同的namePrefix去获取单例线程的线程工厂： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 自定义线程工厂类 */private static class MyThreadFactory implements ThreadFactory &#123; /** * namePrefix --&gt; 线程名字中的计数 */ private static Map&lt;String, AtomicInteger&gt; THREAD_ID_TABLE = new ConcurrentHashMap&lt;&gt;(); /** * 线程名称前缀 */ private String namePrefix; /** * 是否后台线程 */ private boolean isDamon; public MyThreadFactory(String namePrefix) &#123; this(namePrefix, true); &#125; public MyThreadFactory(String namePrefix, boolean isDamon) &#123; this.namePrefix = namePrefix; this.isDamon = isDamon; &#125; @Override public Thread newThread(Runnable r) &#123; String threadName = namePrefix + "-" + generateThreadId(this.namePrefix); Thread thread = new Thread(r, threadName); thread.setDaemon(this.isDamon); System.out.println("创建线程" + threadName); return thread; &#125; private static int generateThreadId(String namePrefix) &#123; // 判断后执行 concurrentHashMap不能保证完全线程安全 用了putIfAbsent if (!THREAD_ID_TABLE.containsKey(namePrefix)) &#123; THREAD_ID_TABLE.putIfAbsent(namePrefix, new AtomicInteger(0)); &#125; return THREAD_ID_TABLE.get(namePrefix).getAndIncrement(); &#125;&#125; 6.handler当满足以下两个条件其中一个的时候，如果继续向线程池中提交新的任务，那么线程池会调用内部的RejectedExecutionHandler对象的rejectedExecution()方法，表示拒绝执行这些新提交的任务： （1）当线程池处于SHUTDOWN状态时（不论线程池和阻塞队列是否已满） （2）当线程池中所有的线程都处于运行状态并且线程池中的阻塞队列已满。 一个demo去演示这两个情况：执行handler的两种情况 当采用默认的拒绝策略，线程池会使用抛出异常的方式来拒绝新任务的提交，这种拒绝方式在线程池中被称为AbortPolicy，我们可以来看下有哪些拒绝策略：（1）AbortPolicy 这中处理方式是直接抛出RejectedExecutionException异常，如果在ThreadPoolExecutor的构造函数中未指定RejectedExecutionHandler参数，那么线程池将使用defaultHandler参数，而这个就是采用的AbortPolicy。 （2）CallerRunsPolicy 将提交的任务放在ThreadPoolExecutor.execute()方法所在的那个线程执行。 （3）DiscardPolicy 直接不执行新提交的任务 （4）DiscardOldestPolicy 这个可以看源码中的解释： 由源码就可以知道，这种处理方式有两种情况：一，当线程池处于SHUTDOWN状态时，就默认不执行这个任务，即DiscardPolicy；二，当线程池处于运行状态时，会将队列中处于队首（head）的那个任务从队列中移除，然后将这个新提交的任务加入到阻塞队列中的队尾（tail）等待执行。 当然，RejectedExecutionHandler其实是个接口，我们可以自定义类去实现这个接口，重写rejectedExecution方法使用自己想要的拒绝策略即可。 下一篇这篇把线程池中的核心参数进行了一些解释，在下一篇中我们将介绍线程池进行任务调度的原理。]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java8增加的接口中默认方法]]></title>
    <url>%2Fblog%2F2018%2F10%2F10%2Fjava8%E5%A2%9E%E5%8A%A0%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言最近在工作中的一次小修改让自己应用到了java8中的新特性：接口默认方法，这里去简单记录下。在java8之后可以在接口定义方法的实现，成为default方法，类似于Scala中的trait。比如在Iterable接口中新增了foreach默认方法： 12345678910111213141516171819202122232425/** * Performs the given action for each element of the &#123;@code Iterable&#125; * until all elements have been processed or the action throws an * exception. Unless otherwise specified by the implementing class, * actions are performed in the order of iteration (if an iteration order * is specified). Exceptions thrown by the action are relayed to the * caller. * * @implSpec * &lt;p&gt;The default implementation behaves as if: * &lt;pre&gt;&#123;@code * for (T t : this) * action.accept(t); * &#125;&lt;/pre&gt; * * @param action The action to be performed for each element * @throws NullPointerException if the specified action is null * @since 1.8 */default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125; 这个default方法的主要目的是为java8的Lambda表达式提供支持，如果将这个方法定义为普通接口方法，则会对现有的JDK的其他使用Iterable接口的类造成影响，因此提供了default方法的功能。 工作中的例子有一个小需求是对一个表的插入的实体的name字段做一个处理，这里name字段如果为空则用手机号（默认手机号不为空）进行插入。因为调用这个insert方法的业务代码比较多，每个都去做这个逻辑会显得很麻烦并且很重复。所以就想到了直接在mapper的xml中去进行修改： 12345insert into table_name ( &lt;if test=&quot;name ==null or name == &apos;&apos;&quot;&gt;NAME,&lt;/if&gt; ) values( &lt;if test=&quot;name == null or name == &apos;&apos;&quot;&gt;#&#123;mobile&#125;&lt;/if&gt;) 这样确实能够实现我们这个小需求，但是这个insert的mapper.xml是通过代码工具自动生成的标准insert方法，并且这样写可读性也不好，给人一种很奇怪的感觉。 这时候就用到了默认方法。这里我们可以在接口中定义一个默认方法insert，然后将之前的insert方法更换名称，在默认方法中去调用更换之后插入方法，而在默认方法中去做如果name为空则用手机号去代替这个逻辑。 12345678910111213int insertDefault(Clues entity);/** * * @param entity * @return */default int insert(Clues entity) &#123; if (StringUtils.isEmpty(entity.getName()) &amp;&amp; StringUtils.isNotEmpty(entity.getMobile())) &#123; entity.setName(entity.getMobile()); &#125; return insertDefault(entity);&#125; 这样原来调用的insert方法也不需要去做更改，并且也不用在xml中进行改动就实现了这个小逻辑。注意要将xml中方insert方法改为insertDefault，这个更改比上边那种修改要显得合理的多。 默认方法的一个总结java是面向对象的语言，那么就会有实现接口和继承父类，那么这些会对接口的默认方法有什么影响呢？下边参考博客：默认方法 存在一个父接口，定义了一个default方法： 12345public interface Parent &#123; default String doit() &#123; return &quot;Parent&quot;; &#125;&#125; 有一个类实现该接口，使用了默认的default方法： 123public class ParentImpl implements Parent&#123;&#125; 有一个ParentImpl2继承了ParentImpl，里面重写了接口中的默认方法： 1234567public class ParentImpl2 extends ParentImpl &#123; @Override public String doit() &#123; return &quot;ParentImpl2&quot;; &#125;&#125; 有一个Child接口继承了Parent接口，并且重写了Parent接口中的默认方法： 12345678910public interface Child extends Parent &#123; /** * 重写父接口中的default方法 * @return */ @Override default String doit() &#123; return &quot;Child&quot;; &#125;&#125; 有一个ChildImpl实现了Child： 12public class ChildImpl implements Child &#123;&#125; 又有一个ChildImpl2继承了ParentImpl2也实现了Child接口，为了测试当子类实现的接口和继承的父类中都有默认方法的场景: 12public class ChildImpl2 extends ParentImpl2 implements Child &#123;&#125; 测试类： 123456789101112131415161718192021222324252627282930313233public class Main &#123; public static void main(String[] args) &#123; /** * 测试实现类可以直接调用接口中的default方法 */ Parent parentImpl = new ParentImpl(); // 将输出Parent System.out.println(parentImpl.doit()); /** * 测试Child接口重写了Parent接口的default方法 */ Child child = new ChildImpl(); // 将输出Child System.out.println(child.doit()); /** * 测试ParentImpl2重写了Parent接口中default方法 */ Parent parentImpl2 = new ParentImpl2(); // 将输出ParentImpl2 System.out.println(parentImpl2.doit()); /** * 测试ChildImpl2父类和实现的接口都有default方法，优先使用父类中定义的方法 */ Child childImpl2 = new ChildImpl2(); // 将输出ParentImpl2 System.out.println(childImpl2.doit()); &#125;&#125; 从上述测试结果可以看出： 实现类可以直接使用父接口中定义的default方法。 接口可以重写父接口中定义的default方法。 实现类可以重写父接口中定义的方法、 当父类和父接口都存在default方法时，使用父类中重写的default方法 特别的，如果一个类实现了两个接口，这两个接口中有同名的default方法签名时，此时会编译不通过，必须在子类中重写这个default方法。]]></content>
      <categories>
        <category>Java语法</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>接口默认方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——ThreadPoolExecutor源码分析（一）]]></title>
    <url>%2Fblog%2F2018%2F10%2F04%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言线程池是并发编程中最重要的应用之一，使用线程池可以防止大量的创建和销毁线程的过程，可以节省很多的内存空间，提高程序的响应率和cpu的利用率，并且也可以对线程进行统一管理和监控。这里将分几篇文章介绍一下线程池的源码分析。本篇是分析ThreadPoolExecutor中的ctl变量。并且去写了线程中的 ctl变量源码中的解释ThreadPoolExecutor中有个字段是ctl，具体来说是对线程池的运行状态和池子中的有效线程数量的控制的一个字段变量，我们可以看看源码中的解释： 123456789101112/** * The main pool control state, ctl, is an atomic integer packing * two conceptual fields * workerCount, indicating the effective number of threads * runState, indicating whether running, shutting down etc * * In order to pack them into one int, we limit workerCount to * (2^29)-1 (about 500 million) threads rather than (2^31)-1 (2 * billion) otherwise representable. If this is ever an issue in * the future, the variable can be changed to be an AtomicLong, * and the shift/mask constants below adjusted. But until the need * arises, this code is a bit faster and simpler using an int. 可以看到ctl是AtomicInteger对象，里面的操作都是基于CAS的原子操作。一个ctl变量包含两部分信息，因为int类型的变量是32位的，所以高3位表示线程池的运行状态（runState），低29位表示线程池中有效线程数（workerCount）。 所以，当我们知道了线程池中的运行状态和有效线程数，就可以通过ctlOf方法计算出ctl的值： 1private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 反过来，我们也可以通过ctl计算出runState和workerCount的值： 12private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; 其中CAPACITY是(2^29)-1， 也就是高三位是0，低29位是1的一个int类型的数字常量。这个CAPACITY表示线程池中有效线程的上限值。这个值的计算过程： 12private static final int COUNT_BITS = Integer.SIZE - 3; // 29private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; 线程池的状态线程池中有五种状态： 123456// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 其中COUNT_BITS的值是29，在后边的源码分析过程中，我们其实只需要知道这几个状态是逐渐递增的即可。比如说在源码中看到 rs &lt; SHUTDOWN 其实就是表示此时线程池的运行状态是RUNNING。 五种状态的解释： （1）RUNNING：运行状态，能接受提交新的任务，并且也能处理阻塞队列中的任务。 （2）SHUTDOWN：关闭状态，不再接受新提交的任务，但是可以处理阻塞在任务队列中已保存的任务。在线程池处于RUNNING状态的时候，调用shutdown方法线程池即变为此状态。 （3）STOP：停止状态，不再接受新提交的任务，也不会处理阻塞队列中已保存的任务，并且会中断正在处理的任务，在线程池处于RUNNING状态或者SHUTDOWN状态的时候，调用shutdownNow方法线程池即进入该状态。 （4）TIDYING：清理状态，所有的任务都已经终止，workerCount有效线程数量为0，线程池进入该状态后调用terminated方法可以使线程池进入Terminated状态。当线程池处于SHUTDOWN状态时，如果此后线程池中没有线程并且阻塞队列中没有要执行的任务，就会进入到这个状态；当线程池处于STOP状态时，如果此时线程池中没有线程了，线程池会进入该状态。（5）TERMINATED：terminated()方法执行之后会进入该状态。 其他字段参数12345678910111213141516171819202122232425262728293031323334//线程池控制器private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));//任务队列private final BlockingQueue&lt;Runnable&gt; workQueue;//全局锁private final ReentrantLock mainLock = new ReentrantLock();//工作线程集合private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();//终止条件 - 用于等待任务完成后才终止线程池private final Condition termination = mainLock.newCondition();//曾创建过的最大线程数private int largestPoolSize;//线程池已完成总任务数private long completedTaskCount;//工作线程创建工厂private volatile ThreadFactory threadFactory;//饱和拒绝策略执行器private volatile RejectedExecutionHandler handler;//工作线程活动保持时间(超时后会被回收) - 纳秒private volatile long keepAliveTime;/** * 允许核心工作线程响应超时回收 * false：核心工作线程即使空闲超时依旧存活 * true：核心工作线程一旦超过keepAliveTime仍然空闲就被回收 */private volatile boolean allowCoreThreadTimeOut;//核心工作线程数private volatile int corePoolSize;//最大工作线程数private volatile int maximumPoolSize;//默认饱和策略执行器 - AbortPolicy -&gt; 直接抛出异常private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); 下一章下一章将会去写一下ThreadPoolExecutor的构造函数和核心参数。]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi命令小总结（二）]]></title>
    <url>%2Fblog%2F2018%2F09%2F30%2Fvi%E5%91%BD%E4%BB%A4%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在vi编辑模式下显示行数在vi编辑模式下可以显示下行数，比如在php调试模式下可以根据相应的行数的代码去打印值调试代码。 方法：在vi模式下输入:set nu即可。也可以直接:line number跳转到对应的行数。 在vi编辑模式中撤回一个操作在INSERT模式下如果写了一些操作，然后想撤回这个操作，按一下esc之后输入u即可。如果是想撤回刚才那个撤回操作，可以按了esc之后点击Ctrl + r。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vi命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot配置swagger]]></title>
    <url>%2Fblog%2F2018%2F09%2F24%2Fspring-boot%E9%85%8D%E7%BD%AEswagger%2F</url>
    <content type="text"><![CDATA[前言swagger是一个很好的restful形式的api文档，可以通过比较小的侵入来提供很好的restful的文档。因为swagger是依赖服务生成的，所以其实是依赖服务的，这也算是它的一个小缺点吧。但是其实如果一个项目习惯去手写文档之后，也是可以的，但是新的项目还是建议去用一些自动生成的文档，省去了很多麻烦。 spring boot配置swagger引入swagger依赖12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 编写swagger对应的配置1234567891011121314151617181920212223242526272829303132333435363738import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; // 文档类型 return new Docket(DocumentationType.SWAGGER_2) // 创建api的基本信息 .apiInfo(apiInfo()) // 选择哪些接口去暴露 .select() // 扫描的包 .apis(RequestHandlerSelectors.basePackage(&quot;com.demo.web.controller&quot;)) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(&quot;groundhog-web swagger文档&quot;) .contact(&quot;name&quot;) .version(&quot;1.0&quot;) .build(); &#125;&#125; 在api和请求参数中使用注解接口中使用swagger注解 123456789101112@RestController@Api(value = &quot;测试swagger&quot;, description = &quot;测试swagger api&quot;)public class TestSwaggerController &#123; @ApiOperation(value = &quot;返回url中的参数&quot;, notes = &quot;返回url中的参数&quot;) @ApiImplicitParam(name = &quot;id&quot;, value = &quot;id值&quot;, paramType = &quot;path&quot;, required = true, dataType = &quot;Integer&quot;) @GetMapping(path = &quot;/getUrlParam/&#123;id&#125;&quot;) public Integer getUrlParam(@PathVariable(value = &quot;id&quot;) Integer id) &#123; return id; &#125;&#125; 可以访问localhost:port/swagger-ui.html看到生成的swagger文档。可以看到请求结果： 也可以看到之前post方法的接口也可以生成对于的参数文档，这里也可以对表单参数bean使用@ApiModel和@ApiProperty注解进行标识。 swagger相关注解和官方文档swagger常用注解： @Api：修饰整个类，描述controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiProperty：用对象接收参数时，描述对象的一个字段 @ApiImplicitParam：一个请求参数 @ApiImplicitParams：多个请求参数 这里推荐下官方文档，感兴趣可以看一下其他注解和相关配置： 注解官方文档]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两个切面配置的记录]]></title>
    <url>%2Fblog%2F2018%2F09%2F21%2F%E4%B8%A4%E4%B8%AA%E5%88%87%E9%9D%A2%E9%85%8D%E7%BD%AE%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前言之前也学习过validate注解去校验一些参数的必要条件，这回工作中用的时候遇到了一些问题。这里都是使用spring boot框架去做的切面，省去了很多不需要的配置。这里去记录一下。 两个切面validate注解这里主要是去使用了hibernate中的注解而去做的切面，之前在博客中写到的整合了两个标准的注解的切面（注意区分下）。看一下切面的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@Aspect@Configurationpublic class ValidateAspect &#123; /** * BEAN对象校验器 配置快速失败模式 */ private final Validator BEAN_VALIDATOR = Validation.byProvider(HibernateValidator.class) .configure() //快速失败模式开启，当检测到有一项失败立即停止 .failFast(true) .buildValidatorFactory().getValidator(); /** * 方法参数对象校验器 */ private final ExecutableValidator METHOD_VALIDATOR = BEAN_VALIDATOR.forExecutables(); /** * point配置 */ @Pointcut(&quot;execution(* com.zhanglijun.springbootdemo.web.controller..*.*(..))&quot;) public void pointcut() &#123; &#125; @Before(&quot;pointcut()&quot;) public void before(JoinPoint point) &#123; // 获得切入目标对象 Object target = point.getThis(); // 获得切入方法参数 Object [] args = point.getArgs(); // 获得切入的方法 Method method = ((MethodSignature)point.getSignature()).getMethod(); // 校验以基本数据类型 为方法参数的 checkWithResult(validMethodParams(target, method, args)); // 校验以java bean对象 for (Object bean : args) &#123; if (null != bean) &#123; checkWithResult(validBeanParams(bean)); &#125; &#125; &#125; /** * 校验bean对象中的参数 * @param bean * @param &lt;T&gt; * @return */ private &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validBeanParams(T bean) &#123; return BEAN_VALIDATOR.validate(bean); &#125; /** * 校验方法中的参数 * @param obj * @param method * @param params * @param &lt;T&gt; * @return */ private &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validMethodParams(T obj, Method method, Object [] params)&#123; return METHOD_VALIDATOR.validateParameters(obj, method, params); &#125; /** * 校验参数校验结果 * @param set */ private void checkWithResult(Set&lt;ConstraintViolation&lt;Object&gt;&gt; set) &#123; if (CollectionUtils.isEmpty(set)) &#123; return; &#125; Iterator&lt;ConstraintViolation&lt;Object&gt;&gt; methodIterator = set.iterator(); if (methodIterator.hasNext()) &#123; throw new IllegalArgumentException(methodIterator.next().getMessage()); &#125; &#125;&#125; 这个可以去实现validate注解的切面配置。 访问接口信息注解还有就是参考翟DD博客中的spring boot配置的一个记录访问接口信息的切面，这里在配置了之后遇到了两个问题，去记录一下。 切面配置12345678910111213141516171819202122232425262728293031323334353637@Aspect@Configuration@Slf4jpublic class WebRequestAspect &#123; // TODO 可以加上sessionUser的获取 @Pointcut(&quot;execution(* com.zhanglijun.springbootdemo.web.controller..*.*(..))&quot;) public void webLog()&#123;&#125; @Before(&quot;webLog()&quot;) public void doBefore(JoinPoint joinPoint) &#123; // 获取request对象 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes == null) &#123; return; &#125; HttpServletRequest request = attributes.getRequest(); log.info(&quot;REQUEST_URL : &#123;&#125;, HTTP_METHOD : &#123;&#125;, ARGS : &#123;&#125;&quot;, request.getRequestURL().toString(), request.getMethod(), JSON.toJSONString(joinPoint.getArgs())); &#125; @AfterReturning(returning = &quot;ret&quot;, pointcut = &quot;webLog()&quot;) public void doAfterReturning(Object ret) &#123; // 打印返回内容 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if (attributes == null) &#123; // 容器启动时也去初始化了切面（因为是execution）这里去判断一下 return; &#125; HttpServletRequest request = attributes.getRequest(); log.info(&quot;REQUEST_URL : &#123;&#125;, RESPONSE : &#123;&#125; &quot;, request.getRequestURL(), JSON.toJSONString(ret)); &#125;&#125; 问题1 fastJson去打印入参在doBefore方法中去做了对方法参数的打印，这里没有思索去用了fastJson去打印参数，但是当去访问一个参数中带有response对象的时，会发生报错。 接口： 123456//========================= 测试web log切面 =====================@GetMapping(path = &quot;/testAspect&quot;, produces = MediaType.APPLICATION_JSON_VALUE)public void testAspect(HttpServletResponse response) &#123; log.info(&quot;测试web log 切面 fastJson序列化response对象会报错&quot;);&#125; 报错： 这个错误在网上找了比较久，也跟进去源码看了，reponse的getOutputSteam在走到切面的这个输出的时候，已经被调用过了，会有一个标志位标志其被调用过，这里如果用fastJson去序列化这个response对象，这里会报错。这就提醒我们这里输出参数不能去使用fastJson去序列化。（有的mapping还是会去用到response对象）。修改方法就是可以把输出参数的部分改成Arrays.toString进行输出。 1Arrays.toString(joinPoint.getArgs())); 这里要注意参数内部的toString方法的实现。 request对象获取的问题这个切面中因为要记录访问的url，所以用到了HttpServletRequest对象，这里获取的方式是：RequestContextHolder.getRequestAttributes()；这个实现的原理就是请求到来的时候去使用ThreadLocal放入request对象，所以在@AfterReturning中也可以去使用这个对象（因为这次请求还没有结束）。但是在项目初始化时，这个切面就会被加载一次，此时并没有请求所以ThreadLocal中也不会有这个request对象。 解决办法：我这里去对request对象做了判断，如果是null的话，那么方法直接返回。 这里也可以去写一下@AfterThrowing之后的处理，可以直接throw出去交给统一异常处理。这里注意切面的order属性和数据层面的事务的order大小顺序。order越小，执行的越靠前。 当你的切面order&gt;数据层面的事务order时，执行顺序是: transaction -&gt; doBefore -&gt; Exception -&gt; @AfterThrowing -&gt; rollback。注意这个时候会造成你的@AfterThrowing内容不生效，一起rollback了。 而当你的切面order &lt; 数据层面事务order时，执行顺序是： dobefore -&gt; transaction -&gt; exception -&gt; rollback -&gt; @AfterThrowing 所以要配置你的webLog切面的order小一些。在spring boot框架中可以通过@Order(level)在类上加上注解进行order控制。]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>validate注解</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vi命令小总结]]></title>
    <url>%2Fblog%2F2018%2F09%2F09%2Fvi%E5%91%BD%E4%BB%A4%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言这篇去写一些最近在工作中get到的关于vi/vim命令的点，简单去记录下。 技能点在文件中快速删除一行在vi编辑文件的时候，发现有时要删除很多的文件内容，这个时候去一点点删除很慢，这里get到了一个快速删除一行的技能。在打开的文件中所要删除的行连续按两次d就可以快速删除一行，然后在用:wq保存即可。 解决没有正确关闭vi打开的文件有的时候我们在查看一个文件之后，直接ctrl+z去退出了文件，当我们再用vim命令去编辑文件的时候，这时候会发现报一个没有正确关闭这个文件的冲突错误，并且你不去解决就会一直存在。 这里get到了去解决的方法，其实也是怪自己一看到一堆英文就不想看下去，这里其实已经写得很清楚了，这里提供了两种情况： （1）有可能另一个人也在编辑这个文件，它提醒你要注意两个人同时编辑不同的地方。 （2）上一次编辑的session还在，这时候提供了解决办法：可以用recover或者vim -r 文件名去修复这个changes。 可以看到当你没正确退出时，还保持着edit session，这时候会生成两个临时文件，我这里采用的是直接删除这两个文件即可。 运行 rm -rf .fileName.* 命令之后，再次打开之后就不会有冲突。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>vi命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot应用拦截器]]></title>
    <url>%2Fblog%2F2018%2F09%2F05%2Fspringboot%E5%BA%94%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[背景在工作中看到了不少项目用到了拦截器，这里去总结一下spring-boot使用拦截器。拦截器是Spring提供的HandlerInterceptor（拦截器），其功能和过滤器类似，但是提供更精细的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request的内容，但可以通过抛出异常（或者返回false）来暂停request的执行。 使用步骤配置拦截器也很简单，spring给我们提供了WebMvcConfigurerAdapter，我们在addInterceptors方法中添加注册拦截器即可。总结起来就是三步： 1.创建我们自己的拦截器类并实现HandlerInterceptor接口。 2.创建一个Java类继承WebMvcConfigurerAdapter，并重写addInterceptors方法。 3.实例化我们自定义的拦截器，然后将对象手动添加到拦截器链中。 代码示例自定义Session信息写入ThreadLocal12345678910111213141516171819202122232425262728293031323334@Slf4j@Componentpublic class SessionInterceptor implements HandlerInterceptor &#123; @Resource private RequestHelper requestHelper; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; log.info(&quot;SessionInterceptor preHandle方法，在请求方法之前调用，Controller方法调用之前&quot;); // MOCK一个SessionUser对象，放入ThreadLocal中 SessionUser sessionUser = new SessionUser(); sessionUser.setId(2L).setName(&quot;夸克&quot;); requestHelper.setSessionUser(sessionUser); // 只有这个方法返回true 请求才能继续下去 return true; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;SessionInterceptor postHandle方法，请求处理之后调用，但是在视图被渲染之前（Controller方法调用之后）&quot;); // 这里可以去做sessionUser的清除 防止内存泄漏 requestHelper.clearSession(); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; log.info(&quot;SessionInterceptor afterCompletion方法，在整个请求结束之后调用，也就是在Dispatcher渲染了整个视图之后进行（主要进行资源清理工作）&quot;); if (Objects.nonNull(requestHelper.getSessionUser())) &#123; requestHelper.clearSession(); &#125; &#125;&#125; 可以看到实现了HandlerInterceptor接口之后，要实现其中的三个方法。 preHandle方法：在请求controller方法之前调用，这里就可以做一些session对象的校验及写入ThreadLocal方便方法调用等。只有这个方法返回true，请求才能继续下去。 postHandle方法：这个方法是在请求了controller方法之后但在视图渲染之前调用的。这里可以去做ThreadLocal中资源的清除。 afterCompletion方法：这个方法是在整个请求结束之后调用的，也就是在Dispatcher渲染整个视图之后进行的，主要进行资源清理工作。（这里也是去补偿了ThreadLocal中资源的清除）。 注册拦截器在WebMvcConfigurerAdapter的子类中注册这个拦截器。WebMvcConfigurerAdapter看名字就提供了很多springmvc关于web访问的配置。 123456789101112131415161718192021222324252627282930@Componentpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; /** * sessionInterceptor不需要拦截的请求 * 比如swagger的请求、比如一些静态资源的访问、比如错误统一处理的页面 */ private static final String[] EXCLUDE_SESSION_PATH= &#123;&#125;; @Resource private SessionInterceptor sessionInterceptor; @Resource private MyInterceptor myInterceptor; /** * 对所有的拦截器组成一个拦截器链 * addPathPatterns 用于添加拦截规则 * excludePathPatterns 用户排除拦截 * * @param registry 拦截器注册对象 */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 加入自定义拦截器到 // registry.addInterceptor(myInterceptor); registry.addInterceptor(sessionInterceptor).excludePathPatterns(EXCLUDE_SESSION_PATH); super.addInterceptors(registry); &#125;&#125; 通过spring管理把自定义的拦截器注册成bean对象，然后通过register的addInterceptor方法注册到拦截器执行链中，这里也可以设置包括/过滤的访问地址等相关子属性。 我们写了个controller去测试这个自定义拦截器。其中helloService是把ThreadLocal中的对象给直接返回 1234567891011121314151617@RestControllerpublic class ThreadLocalController &#123; @Resource private HelloService helloService; /** * 在拦截器中用ThreadLocal * * @return SessionUser */ @GetMapping(value = &quot;/threadLocal/getSessionUser&quot;) public SessionUser getSessionUser() &#123; return helloService.getThreadSessionUser(); &#125;&#125; 1234@Override public SessionUser getThreadSessionUser() &#123; return requestHelper.getSessionUser(); &#125; 在浏览器中访问http://localhost:7001/threadLocal/getSessionUser 可以看到结果返回： 这说明我们的拦截器是正确将sessionUser设置进入ThreadLocal对象的。看控制台的日志输入： 多个自定义拦截器的执行顺序如果再定义一个自定义拦截器，那么执行的顺序是什么呢？ 123456789101112131415161718192021222324252627@Slf4j@Componentpublic class MyInterceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; log.info(&quot;MyInterceptor preHandle方法，在请求方法之前调用，Controller方法调用之前&quot;); // 返回true才能继续执行 return true; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; log.info(&quot;MyInterceptor postHandler方法，请求处理之后调用，但是在视图被渲染之前（Controller方法调用之后）&quot;); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; log.info(&quot;MyInterceptor afterCompletion方法，在整个请求结束之后调用，也就是在Dispatcher渲染了整个视图之后进行&quot; + &quot;主要进行资源清理工作&quot;); &#125;&#125; 在webMvcConfig中注册这两个拦截器，并且在浏览器中访问同样的url。看到控制台的输入。 在webMvcConfig中，我们注册的顺序是先注册了myInterceptor，然后注册了SessionInterceptor，看到的执行顺序为： preHandle方法：myInterceptor先执行 postHandle方法：sessionInterceptor先执行 afterCompletion方法：sessionInterceptor先执行。 可见多个自定义拦截器在执行链中的执行顺序是与注册顺序相关的，preHandle方法是先注册先执行，其他两个方法是后注册的先执行。具体执行的顺序的分析可以见下图。 拦截器的缺点它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。 同时，反射也有可能对性能有些影响。 HandlerInterceptor接口分析1234567891011121314151617181920212223242526272829303132public interface HandlerInterceptor &#123; /** * preHandle方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在 * 多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在 * Controller方法调用之前调用。SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返 * 回值为false，当preHandle的返回值为false的时候整个请求就结束了。 */ boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; /** * 这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之 * 后，也就是在Controller的方法调用之后执行，但是它会在DispatcherServlet进行视图的渲染之前执行，也就是说在这个方法中你可以对ModelAndView进行操 * 作。这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，这跟Struts2里面的拦截器的执行过程有点像， * 只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor * 或者是调用action，然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。 */ void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception; /** * 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行， * 这个方法的主要作用是用于清理资源的，当然这个方法也只能在当前这个Interceptor的preHandle方法的返回值为true时才会执行。 */ void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; &#125; HandlerInterceptorAdapterspringMvc还提供了HandlerInterceptorAdapter这个抽象类，这个抽象类中实现了AsyncHandlerInterceptor接口，而AsyncHandlerInterceptor接口又继承了HandlerInterceptor接口，我们可以首先看下AsyncHandlerInterceptor接口： 12345678910111213141516171819public interface AsyncHandlerInterceptor extends HandlerInterceptor &#123; /** * Called instead of &#123;@code postHandle&#125; and &#123;@code afterCompletion&#125;, when * the a handler is being executed concurrently. * &lt;p&gt;Implementations may use the provided request and response but should * avoid modifying them in ways that would conflict with the concurrent * execution of the handler. A typical use of this method would be to * clean up thread-local variables. * @param request the current request * @param response the current response * @param handler the handler (or &#123;@link HandlerMethod&#125;) that started async * execution, for type and/or instance examination * @throws Exception in case of errors */ void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;&#125; 可以看到在这个接口中添加了一个afterConcurrentHandlingStarted方法。 该方法是用来处理异步请求。当Controller中有异步请求方法的时候会触发该方法。异步请求先支持preHandle、然后执行afterConcurrentHandlingStarted，之后才会执行postHandle的方法。 比如现在我们配置了一个拦截器是用来拦截异步请求的： 123456789101112131415161718192021@Component@Slf4jpublic class MyAsyncHandlerInterceptor extends HandlerInterceptorAdapter &#123; /** * 该方法是用来处理异步请求。当Controller中有异步请求方法的时候会触发该方法。 * 异步请求先支持preHandle、然后执行afterConcurrentHandlingStarted。 * * @param request * @param response * @param handler * @throws Exception */ @Override public void afterConcurrentHandlingStarted(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; super.afterConcurrentHandlingStarted(request, response, handler); log.info(&quot;MyAsyncHandlerInterceptor afterConcurrentHandlingStarted 方法执行&quot;); &#125;&#125; 这个时候我们有个异步请求处理：(对于springMvc的异步请求可以看看这篇博客：springmvc的异步请求) 123456789@RestController@Slf4jpublic class HelloController &#123; @GetMapping(value = &quot;/hello&quot;) public Callable&lt;String&gt; sayHello() &#123; return () -&gt; &quot;controller&quot;; &#125;&#125; 这时在浏览器中调用我们的异步请求，可以看到控制台中输出 可见这时先调用的是afterConcurrentHandlingStarted方法，而后调用的是postHandle方法。 我们再去看适配器HandlerInterceptorAdapter的代码： 12345678910111213141516171819202122232425262728293031323334353637383940public abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor &#123; /** * This implementation always returns &#123;@code true&#125;. */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; return true; &#125; /** * This implementation is empty. */ @Override public void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; &#125; /** * This implementation is empty. */ @Override public void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; &#125; /** * This implementation is empty. */ @Override public void afterConcurrentHandlingStarted( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; &#125;&#125; 可以看到preHandle方法默认实现返回了true，比如我们只想去定义一个拦截器去在方法执行完之后去释放掉一些资源，如果去实现HandlerInterceptor则显得有点麻烦。这里只要去继承这个抽象类，实现afterCompletion方法即可。 github上述代码都能在gitHub上看到：https://github.com/zhanglijun1217/spring-boot-demo]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>拦截器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function函数式接口的优化代码应用]]></title>
    <url>%2Fblog%2F2018%2F09%2F02%2FFunction%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言函数式接口之前就一直在接触过，之前在github上写过关于几个函数式接口简单应用的代码，但一直没有记录在工作中的应用，这次就用Function接口优化了一次重复代码的警告。关于函数式接口不熟悉的同学，可以先看下我在github上的代码工程：java8 优化记录优化前的代码数据底层提供了查询报表四个不同纬度的接口，而接口中的方法其实都是一样的：比如通过部门去查、通过部门下的人去查找报表数据，而在应用层如果去写这些查询接口的话，就是每种报表都要去查子部门和人员的数据（真实的情况更多），那么很自然的就在每种报表的实现方法中去根据查询部门还是人或者其他的可能的去进行数据的查询。 这里可以看到，这只是销售报表这一种情况，然后比如成单量、业绩额、成单率等等也是这样写的。这时候在IDEA中就会报一个警告：Duplicated Code，因为除了调用底层的接口不一样之外，其余的逻辑都是一样，并且这四个service没有去继承一个抽象类去做封装，并且这四个的返回值也不能去做抽象，并且在最后是要根据返回值的类型去进行bean转换，这时候不能简单的去根据泛型去抽象出private方法，这里想到了用函数式接口去做。 优化过程Function接口定义注意到查询底层报表数据是有的要传入两个参数的，也有的是要传入三个参数的，所以我们就需要多参数的Function接口，Java中为我们提供了BiFunction，也就是两个参数的Function接口，但是三个参数的函数式接口要我们自己定义。这里去定义一个传入三个参数和一个返回值的函数式接口。 1234567891011121314@FunctionalInterfacepublic interface TripleFunction&lt;T, U, K, R&gt; &#123; /** * Applies this function to the given arguments * * @param t the first function argument * @param u the second function argument * @param k the third function argument * @return the function result */ R apply(T t, U u, K k);&#125; 这里可以看到这个接口中有@FunctionalInterface注解和apply方法。 查询报表逻辑处理这里去写一个查询报表的通用逻辑处理。首先看参数，condition是传入的筛选条件，clazz是返回值泛型R的class，queryUserFun是传入两个参数的计算出T的的函数，同样queryDeptByIdFunc是传入两个参数，计算出PlainResult的函数式参数。剩下两个函数参数是传入三个参数计算出ListResult参数。 这里为什么要去传R、T两个泛型？因为这里直接调用rpc接口返回的结果是他们封装的一个DTO对象，我们要自爱应用层自己运用orika工具进行DTO的转换（防污染和降低耦合）。那为什么要单独去传入一个最后返回值得class对象？这里是因为泛型在运行时会被擦除，要使用orika去转换DTO时要进行class的参数传入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 查询报表的方法 * * @param condition 筛选条件 * @param clazz 结果class * @param queryUserFunc 查询user函数 * @param queryUsersFunc 查询users函数 * @param queryDeptFunc 查询dept函数 * @param &lt;T&gt; 泛型1 * @param &lt;R&gt; 泛型2 * @return */ private &lt;T, R&gt; Pagination&lt;R&gt; getReport(AchievementPkDTO condition, Class&lt;R&gt; clazz, BiFunction&lt;Long, DateRangeDTO, ListResult&lt;T&gt;&gt; queryUserFunc, BiFunction&lt;Long, DateRangeDTO, PlainResult&lt;T&gt;&gt; queryDeptByIdFunc, TripleFunction&lt;Long, DateRangeDTO, OrderAndPageDTO, ListResult&lt;T&gt;&gt; queryUsersFunc, TripleFunction&lt;Long, DateRangeDTO, OrderAndPageDTO, ListResult&lt;T&gt;&gt; queryDeptFunc) &#123; DateRangeDTO dateRangeDTO = convertDateRangeDTO(condition); OrderAndPageDTO orderAndPageDTO = convertOrderAndPageDTO(condition); // 初始化 ListResult&lt;T&gt; result = new ListResult&lt;&gt;(); // 如果是有赞部门节点 if (OrganizationType.YOUZAN_SUB_DEPARTMENTS.equals(condition.getOrganizationType())) &#123; result = queryDeptFunc.apply(condition.getOrganizationId(), dateRangeDTO, orderAndPageDTO); &#125; else if (OrganizationType.YOUZAN_USER.equals(condition.getOrganizationType())) &#123; // 人的节点 result = queryUserFunc.apply(condition.getOrganizationId(), dateRangeDTO); &#125; else if (OrganizationType.YOUZAN_DEPARTMENT_USERS.equals(condition.getOrganizationType())) &#123; // 部门人的节点 result = queryUsersFunc.apply(condition.getOrganizationId(), dateRangeDTO, orderAndPageDTO); &#125; else if (OrganizationType.SINGLE_PROVIDER.equals(condition.getOrganizationType())) &#123; // 单个渠道商节点 PlainResult&lt;T&gt; apply = queryDeptByIdFunc.apply(condition.getOrganizationId(), dateRangeDTO); // 设置result信息 result.setData(Collections.singletonList(CheckWrapper.checkWrap(apply))); result.setCount(1); result.setSuccess(true); &#125; List&lt;R&gt; rList = orikaBeanUtil.convertList(CheckWrapper.checkWrap(result), clazz); return new Pagination&lt;&gt;(rList, condition.getPage(), condition.getPageSize(), result.getCount()); &#125; 实现不同种报表的查询有了上述通过Function接口的改造，使得不同的业务场景（业绩、成单量等）都可以传入一个lambda表达式去调用上边封装的获取参数的方法。比如下面的这两个方法（这样并不会报Duplicated Code警告）： 12345678910111213141516171819202122232425262728293031@Override public Pagination&lt;DealAmountStatistics&gt; getDealReport(AchievementPkDTO condition) &#123; if (Objects.equals(OrganizationType.PROVIDER, condition.getOrganizationType())) &#123; return doWithDealProvider(condition); &#125; else &#123; return getReport(condition, DealAmountStatistics.class, (organizationId, date) -&gt; dealAmountStatisticsService.getUserById(organizationId, date), (organizationId, date) -&gt; dealAmountStatisticsService.getDepartmentById(organizationId, date), (organizationId, date, range) -&gt; dealAmountStatisticsService.getUsersByDepartmentId(organizationId, date, range), (organizationId, date, range) -&gt; dealAmountStatisticsService.getDepartmentsByParentId(organizationId, date, range)); &#125; &#125; @Override public Pagination&lt;OrderNumStatistics&gt; getOrderNumberReport(AchievementPkDTO condition) &#123; if (Objects.equals(OrganizationType.PROVIDER, condition.getOrganizationType())) &#123; return doWithOrderNumProvider(condition); &#125; else &#123; return getReport(condition, OrderNumStatistics.class, (organizationId, date) -&gt; orderNumStatisticsService.getUserById(organizationId, date), (organizationId, date) -&gt; orderNumStatisticsService.getDepartmentById(organizationId, date), (organizationId, date, range) -&gt; orderNumStatisticsService.getUsersByDepartmentId(organizationId, date, range), (organizationId, date, range) -&gt; orderNumStatisticsService.getDepartmentsByParentId(organizationId, date, range)); &#125; &#125; 这里去因为PROVIDER类型节点要对不同的返回值做特殊处理，否则这两个方法还可以抽象成为一个公用方法，这里不去对抽象过多要求，主要想记录学习的是用函数式接口去优化代码减少了代码重复行数，并且lambda表达式作为参数的一个使用也没有降低可读性。之后在写代码的过程中可以多应用这种设计，去让代码变得更加简洁，使用更多的新特性。]]></content>
      <categories>
        <category>Java语法</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>函数式接口</tag>
        <tag>代码优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次freemarker错误排查]]></title>
    <url>%2Fblog%2F2018%2F08%2F29%2F%E8%AE%B0%E4%B8%80%E6%AC%A1freemarker%E9%94%99%E8%AF%AF%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[前言在最近的工作中遇到了一个做一个导出功能时遇到了一个很奇怪的事情，逻辑是先做一个export方法上传到文件服务器上，然后重定向到一个doExport方法中，这个doExport方法中是去判断这个文件是否生成（之前生成Excel文件是异步线程生成的），如果没有生成，则转到一个export.ftl的freemarker页面，这个页面中去不断reload去调用这个doExport方法，直到导出了文件。但是在本地测试的时候，总发现doExport方法会无限的将请求再转发到export方法中，然后就一直产生了无限重定向，在浏览器中会有报无限重定向而给拦截掉。 现象两个controller： 模板文件： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;报表导出&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div style=&quot; border:1px solid #ccc; margin:200px auto; height:70px;background:#eee;padding:40px;color:green;text-align:center;&quot;&gt;正在生成报表，请耐心等待...&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; setTimeout(&quot;location.reload()&quot;, 1000);&lt;/script&gt;、&lt;/body&gt;&lt;/html&gt; 本地开启debug模式进行调试： 可以看到现在是线程nio-7001-exec-1去发送到重定向到下边的doExport方法 此时在doExport中是新的exec-2线程去调用这个方法判断文件是否存在 同样的是这个线程去返回modelAndView，按理说这时候应该返回模板类freemarker中的export.ftl，但是它没有去返回freemarker文件，而是将这个请求转发到了export方法： 而且是同一个线程，是容器内跳转。之后因为每次export方法都会去生成一个新的随机的文件名称，所以又会去调用doExport方法去下载新的文件名称的文件，直到有一个个文件内容比较少，异步线程在判断文件是否存在之前，文件导出，否则浏览器会直接拦截这么多次的重定向： 排查过程是不是freemarker的文件路径配置有问题既然是容器内跳转，而没有访问到真正的导出页面的文件，那是不是freemarker的文件访问路径配置有问题。看到本地环境的properties文件中关于freemarker配置如下： 12345678# freemarker相关配置spring.freemarker.enabled=truespring.freemarker.suffix=.ftlspring.freemarker.content-type=text/htmlspring.freemarker.cache=falsespring.freemarker.charset=utf-8spring.freemarker.check-template-location=truespring.freemarker.template-loader-path=classpath:/templates/ 这里去查看了模板文件确实是放在了classpath下的templates文件夹中的。所以配置和访问文件的路径没有问题。 是不是因为mapping重名，优先映射到了mapping地址这里发现模板文件的名称和export的mapping地址是一样的，则在exprot方法上加了一个1,saleDetail/exprot1这样，然后再次debug发现，这时候不会再重新容器内跳转到这个方法，但是页面直接报了404错误，这说明还是没有去加载到模板文件。 进行一个简答的路由到模板文件的测试这时候去写了一个helloController，然后在templetes下新建了一个hello.ftl模板文件，在controller中去return modelAndView，这时视图也是hello，发现也是404的错误。这说明和sendRedirect方法也没有关系，本身项目是不支持freemarker的。 最后发现在整个项目中，都没有freemarker的依赖和jar包。。。加入freemarker的依赖之后问题解决。 因为mapping地址和freemarker的模板文件地址相同，在你返回modelAndView的视图名称在mapping中找的到时，springmvc会容器内跳转，也不会报freemarker模板文件找不到的错误。因为其他工程也是这样去写的，所以就想当然的以为这个工程中也会有freemarker依赖。其实这个时候应该跟一下spring mvc的源码，就可以看到这时候跳转的是dispatcherServlet路由到的export方法，并没有走freemarker的模板文件。这里去记录一下。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot actuator]]></title>
    <url>%2Fblog%2F2018%2F08%2F25%2Fspring-boot-actutor%2F</url>
    <content type="text"><![CDATA[前言spring boot的一大特性就是自带的actuator。它是spring-boot框架提供的对应系统的自省和监控的集成功能，可以对系统进行配置查看、相关功能统计等。 actuator的使用引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 配置文件的配置 management.port:指定访问监控防范的端口，这个端口应该与逻辑端口分离。如果不想使actuator暴露在http中，可以设置这个端口为7002。 management.address：指定地址，比如只能通过本机监控，可以设置 management.address = 127.0.0.1启动项目，可以看到actuator启动在了配置的7002端口，并且提供了可以访问其中的一些endPoints。 一些主要的EndPointsspring-boot提供了一些常用的EndPoints 其中鉴权为true的表示访问这些endPoints是需要保护的不能随意进行访问的。如果要取消，可以设置关闭鉴权（低版本的spring-boot没有提供鉴权） 1management.security.enable=false 官方文档可以看到这个监控和自省的功能是十分有用的，可以看到bean信息、dump信息、mapping信息和访问链路信息等，所以这个功能在官方文档中也说的很清楚，我们也可以通过实现HealthIndicator接口，编写自己的health接口，也可以增加自己的监控接口。具体的还可以看一下官方文档 acautor文档]]></content>
      <categories>
        <category>spring</category>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
        <tag>actuator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[validate注解做校验]]></title>
    <url>%2Fblog%2F2018%2F08%2F18%2Fvalidate%E6%B3%A8%E8%A7%A3%E5%81%9A%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[前言之前也用过hibernate的校验注解，但是没有去做一个总结，这里参考一篇博客去做一个总结。简述JSR303/JSR-349，hibernate validation，spring validation之间的关系。JSR303是一项标准,JSR-349是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如@Null，@NotNull，@Pattern，他们位于javax.validation.constraints包下，只提供规范不提供实现。而hibernate validation是对这个规范的实践（不要将hibernate和数据库orm框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，他们位于org.hibernate.validator.constraints包下。而万能的spring为了给开发者提供便捷，对hibernate validation进行了二次封装，显示校验validated bean时，你可以使用spring validation或者hibernate validation，而spring validation另一个特性，便是其在springmvc模块中添加了自动校验，并将校验信息封装进了特定的类中。这无疑便捷了我们的web开发。本文主要介绍在springmvc中自动校验的机制。 引入依赖因为我们构建的是spring boot项目，所以直接引入web的starter的依赖即可。123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果查看其子依赖，可以发现如下的依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;&lt;/dependency&gt; 进行校验校验的实体类这里用了lombok的@Data注解，也是非常推荐大家使用的一个插件。12345678910111213141516171819202122232425@Datapublic class ValidateBO &#123; @NotBlank(message = &quot;name不能为空&quot;) private String name; @Min(value = 18, message = &quot;年龄不能小于18岁&quot;) private Integer age; @Email(message = &quot;email格式错误&quot;) private String email; /** * 自定义注解 不能包含空格字符串 */ @CannotHaveBlank private String blank; /** * 正则校验 */ @Pattern(regexp = &quot;^1(3|4|5|7|8)\\d&#123;9&#125;$&quot;, message = &quot;手机号码格式错误&quot;) private String phone;&#125; 可以看到这里用到了一些常见的注解。（自定义校验注解在下边会提到） controller进行校验在controller中进行这个字段的校验，可以看到每个需要校验的对象，都需要一个BindingResult去承接校验的结果，并且也要对要校验的类去加上@Validated注解。123456789101112@GetMapping(value = &quot;/validate&quot;) public String validate(ValidateBO validateBO, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; StringBuilder stringBuilder = new StringBuilder(); for (String s : bindingResult.getFieldErrors().stream() .map(FieldError::getDefaultMessage).collect(Collectors.toList())) &#123; stringBuilder.append(s); &#125; return stringBuilder.toString(); &#125; return &quot;success&quot;; &#125; 启动项目，在url中输入对项目进行debug。可以看到，校验在碰到第一个字段不符合要求之后，并不是直接返回错误，而是会对所有的要校验字段去校验。当然这个也是可以配置的，下边会提到fast-fail的配置。最后返回的结果：这里是打印出了这个对象中所有的错误。 常见的校验注解JSR提供的校验注解:12345678910111213@Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator提供的校验注解：12345@NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内 分组校验场景如果同一个类，在不同的使用场景下有不同的校验规则，那么可以使用分组校验。未成年人是不能喝酒的，而在其他场景下我们不做特殊的限制，这个需求如何体现同一个实体，不同的校验规则呢？ 校验对象12345678910111213@Datapublic class ValidateByGroupBO &#123; /** * 只有adult组内才进行 validate 校验 */ @Min(value = 18, groups = &#123;Adult.class&#125;) private Integer age; public interface Adult&#123;&#125; public interface Minor&#123;&#125;&#125; 这就定义了只有在在adult组内才会进行最小值18的校验。 进行验证1234567891011121314151617181920212223242526272829/** * 喝酒这个去校验了年龄值，因为只有adult这个组才去校验年龄 * @param validateByGroupBO * @param bindingResult * @return */ @GetMapping(value = &quot;/drink&quot;) public String drink(@Validated(&#123;ValidateByGroupBO.Adult.class&#125;) ValidateByGroupBO validateByGroupBO, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; // 处理错误 return &quot;false&quot;; &#125; return &quot;success&quot;; &#125; /** * 生活不需要去校验adult的分组 就不去校验对应的age的最小值 * @param validateByGroupBO * @param bindingResult * @return */ @GetMapping(value = &quot;live&quot;) public String live(@Validated ValidateByGroupBO validateByGroupBO, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; // 错误处理 return &quot;false&quot;; &#125; return &quot;success&quot;; &#125; 运行之后，在url中输入http://localhost:7001/drink?age=10，第一个返回false，因为指定了使用其中的Adult分组，会开启对age的校验。输入http://localhost:7001/live?age=10则会不去校验age的大小，返回success。喝酒要校验是否成年，而生活不用，类似的场景还是很容易碰到的。 自定义注解实现一个注解这里去实现一个字符串中不能含有blank空格。主要分为两步： 先去定义这个注解，其中validatedBy指定的是真正去做校验的实体类。而其中的groups和payload可以直接用默认。 123456789101112131415161718192021222324@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, ElementType.CONSTRUCTOR, PARAMETER&#125;)@Retention(RUNTIME)@Documented// 这个注解是引入真正的去做验证的类@Constraint(validatedBy = &#123;CannotHaveBlankValidator.class&#125;)public @interface CannotHaveBlank &#123; // 默认错误信息 String message() default &quot;不能包含空格&quot;; // 分组 Class&lt;?&gt;[] groups() default &#123;&#125;; //负载 Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;; //指定多个时使用 @Target(&#123;FIELD, METHOD, PARAMETER, ANNOTATION_TYPE&#125;) @Retention(RUNTIME) @Documented @interface List &#123; CannotHaveBlank[] value(); &#125;&#125; 第二步是去实现真正去做校验的实体类 12345678910111213141516171819202122232425public class CannotHaveBlankValidator implements ConstraintValidator&lt;CannotHaveBlank, String&gt; &#123; @Override public void initialize(CannotHaveBlank cannotHaveBlank) &#123; &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; //null时不进行校验 if (value != null &amp;&amp; value.contains(&quot; &quot;)) &#123; //获取默认提示信息 String defaultConstraintMessageTemplate = context.getDefaultConstraintMessageTemplate(); System.out.println(&quot;default message :&quot; + defaultConstraintMessageTemplate); //禁用默认提示信息 context.disableDefaultConstraintViolation(); //设置提示语 context.buildConstraintViolationWithTemplate(&quot;can not contains blank&quot;) .addConstraintViolation(); return false; &#125; return true; &#125;&#125; 这里去实现类去实现了ConstraintValidator接口，这个接口中包含一个初始化事件方法和一个判断是否合法的方法：123456789package javax.validation;import java.lang.annotation.Annotation;public interface ConstraintValidator&lt;A extends Annotation, T&gt; &#123; void initialize(A var1); boolean isValid(T var1, ConstraintValidatorContext var2);&#125; 其中的A泛型参数是上一步定义的注解类，泛型T是要去校验的字段类型。ConstraintValidatorContext 这个参数上下文包含了认证中所有的信息，我们可以利用这个上下文实现获取默认错误提示信息，禁用错误提示信息，改写错误提示信息等操作。 自定义注解进行校验还是用第一个controller去验证这个自定义注解。因为要校验的对象中加入了自定义注解的blank字段。启动项目，输入http://localhost:7001/validate?blank=19 209（这里加了空格），可以看到返回值是：说明自定义注解起到了作用。 @Valid 和 @Validated的区别https://blog.csdn.net/qq_27680317/article/details/79970590这篇讲的很清晰了。 aop很显然，如果我们每个controller中的方法都去写BindingResult就显得很麻烦了，其实我们就是要对参数进行校验并且输出到log中，这就很自然的想到了aop。 注解标识定义一个注解去标识使用了hibernate validate注解123456789101112131415161718192021package com.zhanglijun.springbootdemo.domain.anno;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import javax.validation.groups.Default;/** * 用来表示开启hibernate校验的注解 * @author 夸克 * @create 2018/8/19 22:28 */@Target(&#123;ElementType.METHOD,ElementType.TYPE,ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface EnableValidate &#123; Class&lt;?&gt; [] groups() default &#123; Default.class &#125;;//校验分组信息&#125; 定义切面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162package com.zhanglijun.springbootdemo.aspect;import com.zhanglijun.springbootdemo.domain.anno.EnableValidate;import java.lang.annotation.Annotation;import java.lang.reflect.Method;import java.util.HashSet;import java.util.Set;import javax.validation.ConstraintViolation;import javax.validation.ConstraintViolationException;import javax.validation.Validation;import javax.validation.Validator;import javax.validation.executable.ExecutableValidator;import lombok.extern.slf4j.Slf4j;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.aspectj.lang.reflect.MethodSignature;import org.hibernate.validator.HibernateValidator;import org.springframework.core.annotation.AnnotationUtils;import org.springframework.stereotype.Component;import org.springframework.util.ClassUtils;/** * @author 夸克 * @create 2018/8/19 18:45 */@Slf4j@Aspect@Componentpublic class ValidatorAspect &#123; /** * 获取校验的工厂的信息 */ private static final Validator validator = Validation.byProvider(HibernateValidator.class) .configure() //快速失败模式开启，当检测到有一项失败立即停止 .failFast(true) .buildValidatorFactory().getValidator(); /** * point配置 */ @Pointcut(&quot;execution(* com.zhanglijun.springbootdemo.web.controller..*.*(..))&quot;) public void pointcut() &#123; &#125; /** * @desction: 校验步骤 1.首先校验是否含有基本的Hibernate validator 注解，有异常抛出 2.校验方法参数中是否含有EgValidate注解，获取分组信息，进行Bean级别的校验，有异常抛出 * 3.查看当前的方法中（优先级高）(或者父类、父接口)是否含有EgValidate注解，没有获取当前类的中是否是否含有EgValidate注解，获取分组信息，针对每一个非基本类型Bean进行校验，有异常掏出 * @author: wangji * @date: 2018/3/13 10:16 */ @Before(&quot;pointcut()&quot;) public void before(JoinPoint point) &#123; // 获得切入目标对象 Object target = point.getThis(); // 获得切入方法参数 Object[] args = point.getArgs(); // 获得切入的方法 Method method = ((MethodSignature) point.getSignature()).getMethod(); Annotation[] classAnnotations = target.getClass().getAnnotations(); Annotation[] methodAnnotations = method.getAnnotations(); Annotation[][] parameterAnnotations = method.getParameterAnnotations(); //如果方法参数有基本的注解，就进行Hibernate validator 基本的参数校验 if (parameterAnnotations != null) &#123; validMethodParams(target, method, args); &#125; // 判断参数中是否含有EgValidate注解，进行特殊分组，Bean级别的参数校验 int i = 0; //排查掉已经在参数中校验过的参数不适用类或者方法上的校验参数在次进行校验 Set&lt;Integer&gt; idSet = new HashSet&lt;&gt;(3); for (Object arg : args) &#123; if (arg != null) &#123; if (parameterAnnotations != null) &#123; for (Annotation parameterAnnotation : parameterAnnotations[i]) &#123; if (parameterAnnotation instanceof EnableValidate) &#123; if (!ClassUtils.isPrimitiveOrWrapper(arg.getClass())) &#123; validBeanParam(arg, ((EnableValidate) parameterAnnotation).groups()); idSet.add(i); &#125; &#125; &#125; &#125; i++; &#125; &#125; // 如果没有异常继续校验当前的每一个非基本类型的参数 EnableValidate egValidate = null; //方法上是否有校验参数 if (methodAnnotations != null) &#123; egValidate = AnnotationUtils.findAnnotation(method, EnableValidate.class); &#125; // 类上是否含有 if (egValidate == null &amp;&amp; classAnnotations != null) &#123; egValidate = AnnotationUtils.findAnnotation(target.getClass(), EnableValidate.class); &#125; // 如果在类或者方法上加了验证注解 ，则对所有非基本类型的参数对象进行验证,不管参数对象有没有加注解，使用方法上的分组 if (egValidate != null &amp;&amp; args != null &amp;&amp; args.length &gt; 0) &#123; i = 0; for (Object arg : args) &#123; if (arg != null &amp;&amp; !ClassUtils.isPrimitiveOrWrapper(arg.getClass()) &amp;&amp; !idSet .contains(i)) &#123; validBeanParam(arg, egValidate.groups()); &#125; i++; &#125; &#125; &#125; /** * @param obj 参数中的Bean类型参数 * @param groups 分组信息 * @desction: 进行参数中的Bean校验 * @author: wangji * @date: 2018/3/13 10:10 */ private void validBeanParam(Object obj, Class&lt;?&gt;... groups) &#123; Set&lt;ConstraintViolation&lt;Object&gt;&gt; validResult = validator.validate(obj, groups); throwConstraintViolationException(validResult); &#125; /** * @param obj 当前的实例 * @param method 实例的方法 * @param params 参数 * @desction: 对于Hibernate 基本校验Bean放在参数中的情况的校验 【例如 User getUserInfoById(@NotNull(message = * &quot;不能为空&quot;) Integer id);】 * @author: wangji * @date: 2018/3/13 10:11 */ private void validMethodParams(Object obj, Method method, Object[] params) &#123; ExecutableValidator validatorParam = validator.forExecutables(); Set&lt;ConstraintViolation&lt;Object&gt;&gt; validResult = validatorParam .validateParameters(obj, method, params); throwConstraintViolationException(validResult); &#125; /** * @desction: 判断校验的结果是否存在异常 * @author: wangji * @date: 2018/3/13 10:09 */ private void throwConstraintViolationException(Set&lt;ConstraintViolation&lt;Object&gt;&gt; validResult) &#123; if (!validResult.isEmpty()) &#123; throw new ConstraintViolationException(validResult.iterator().next().getMessage(), validResult); &#125; &#125;&#125; 这个切面说的也很清除，对多处使用这个的地方都去做了一个校验。 github上述代码都在我的github，可以在review一下代码。validated注解相关 引用参考的博客： https://www.cnkirito.moe/spring-validation/ https://blog.csdn.net/oKuZuoZhou/article/details/81024795 https://blog.csdn.net/u012881904/article/details/79538895]]></content>
      <categories>
        <category>spring</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>validate注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——ThreadLocal总结]]></title>
    <url>%2Fblog%2F2018%2F08%2F16%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94ThreadLocal%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[概念介绍ThreadLocal是早期jdk版本中就有的一个工具，基本原理是同一个ThreadLocal所包含的对象（对ThreadLocal而言即为String类型变量），在不同的Thread中有不同的副本（实际是不同的实例）。这里有几点需要注意：​ 因为每个Thread内有自己的实例副本，且该副本只能由当前的Thread使用。这也是ThreadLocal命名的由来。 既然每个Thread都有自己的实例副本，且其他的Thread不可访问，那么就不存在多线程共享的问题（其实ThreadLocal也不是去解决多线程共享的问题）。 那么ThreadLocal解决了什么问题呢？ThreadLocal提供了线程本地的实例。它与普通变量的区别在于，每个使用该变量的线程都会初始化一个完全独立的实例副本。ThreadLocal变量通常被private static修饰。当一个线程结束时，它所使用的ThreadLocal相对的实例副本都可被回收。 ThreadLocal的适用场景：ThreadLocal适用于每个线程需要自己独立的实例且该实例需要在多个方法中使用，也即变量在线程间隔离而在方法或类间共享的场景。其实这种场景下并不只是可以用ThreadLocal去解决，只不过ThreadLocal更简洁。 ThreadLocal原理实现可能的猜想ThreadLocal维护线程与实例的映射 既然每个访问ThreadLocal变量的线程都有自己的一个“本地”实例副本，那么可能的方案是ThreadLocal维护着一个Map，键是Thread，值是它在这个Thread中的实例。线程通过该ThreadLocal的get()方法获取实例时，只需要以线程为键，从map中获取实例即可。 这个方案却又有问题： 增加线程和减少线程都需要去put、remove操作map,这个时候如果在一个ThreadLocal对该线程存入两个实例，就会有线程安全问题、 线程结束时，需要保证它所访问的所有的ThreadLocal中的对应的映射均删除，否则可能会引起内存泄漏。 第一个问题是jdk不去采取这种做法的原因。 ThreadLocal维护ThreadLocal与实例的映射 如果这个Map是每个线程去访问自己的一个Map，就不会产生多线程写的问题。map中维护着key为ThreadLocal实例，设计如下图所示。 这个方案中解决了map的线程安全问题，相当于第一种方法的倒转想法，map中key设置为ThreadLocal实例在不同线程中访问。 这种方案还是没有去解决内存泄漏问题。由于每个线程访问到ThreadLocal变量之后，都会在自己的Map内维护该ThreadLocal变量与具体实例的映射，如果不删除这些引用（映射），则这些ThreadLocal不能被回收，可能会造成内存泄漏。 JDK中的解决ThreadLocalMap 上边提到的维护的map是由ThreadLocal中的静态内部类ThreadLcoalMap去提供的，该类的实例维护着某个ThreadLocal与具体实例的映射。与HashMap不同的是，每个ThreadLocalMap的每一个Entry都是一个对键的弱引用，这一点可以从super(k)可以看出。每一个Entry对key的引用是强引用。使用ThreadLocal弱引用的原因是可以被及时回收。但是这里不能解决Entry引用内存泄漏的问题。当ThreadLocal变量被回收之后，该映射的键值变为null，该Entry无法被移除。从而也有可能造成内存泄漏。（下面会提到JDK的解决）ThreadLocalMap中的Entry代码如下：12345678static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125; 读取实例12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(&quot;unchecked&quot;) T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; 读取实例时，线程首先通过getMap(t)方法获取自身的ThreadLocalMap。获取到ThreadLocalMap后，通过map.getEntity(this)方法获取该ThreadLocal在当前线程的ThreadLocalMap中的Entry。该方法中的this即当前访问的ThreadLocal方法。如果获取到的Entry不为null，从Entry中取出值即为所需访问的本线程对应的实例。如果获取到的Entry为null，则通过setInitialValue()方法设置该ThreadLocal变量在该线程中对应的具体实例的初始值。设置初始值的方法如下： 12345678910private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125; 注意此方法为private方法，无法被重载。 首先，通过initialValue()方法能生成一个初始值，这个方法是一个public方法，且默认值为null。所以典型用法中常常去重载该方法去给一个默认值。然后，通过当前线程对象拿到ThreadLocalMap对象，若该对象不为null，则直接塞入map中set进去线程内实例的值。如果map为null，则去创建该ThreadLcoalMap对象。 设置实例。 设置实例的方法也是采用了上述方法中的原理，不多做解释了。12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); &#125; 防止内存泄漏 对于已经不再使用且已被回收的ThreadLocal对象，它在每个线程内对应的实例由于被线程的TheradLcoalMap的Entry强引用，无法被回收，可能会造成内存泄漏。 针对该问题，ThreadLocal的set方法中去做了处理。replaceStaleEntry方法将所有键为null 的Entry的值设置为null，从而使得该值可被回收。另外，会在rehash方法中通过 expungeStaleEntry 方法将键和值为null的Entry设置为null从而使得该 Entry可被回收。通过这种方式，ThreadLocal可防止内存泄漏。 1234567891011121314151617181920private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; ThreadLocal的适用场景 每个线程需要自己有单独的实例 实例需要在对个方法中共享，但不希望被多线程共享。 Threadlocal一个工具类总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * threadLocal工具类 * @author 夸克 * @create 2018/8/15 16:47 */public class ThreadLocalUtil &#123; /** * 不同的业务区分ThreadLocal中map的key * （这里的map不是threadLocal中对应线程的threadLocalMap，而是要塞入线程中的map的值， * 这里可能在一个业务域中一个线程存在多次使用ThreadLocal，所以在threadLocal中塞入的是个map。而 * 当前线程中存放的是&lt;threadLocal对象,&lt;业务key, 真正要使用的变量&gt;&gt;） * threadLocal内存泄漏问题（（1）ThreadLocalMap中Entry的引用没有释放）在jdk8中得到了解决， * 对ThreadLocalMap中的键值threadLocal实例的引用改为弱引用 * 所以建议使用ThreadLocal */ /** * 业务前缀key值的维护 */ public enum Key &#123; /** * 测试使用 */ COMMON_TEST(&quot;COMMON_TEST&quot;); private String key; Key(String key) &#123; this.key = key; &#125; &#125; private static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;(); /** * set方法 * @param key * @param value */ public static void set(String key, Object value) &#123; if(THREAD_LOCAL.get() == null) &#123; // 初始化 init(); &#125; if (StringUtils.isEmpty(key) || Objects.isNull(value)) &#123; return; &#125; THREAD_LOCAL.get().put(key, value); &#125; /** * get方法 * @param key * @return */ public static Object get(String key) &#123; if (StringUtils.isEmpty(key)) &#123; return null; &#125; return THREAD_LOCAL.get().get(key); &#125; /** * 刷新方法 */ public static void refresh() &#123; if (THREAD_LOCAL.get() == null) &#123; return; &#125; // map清除 key value THREAD_LOCAL.get().clear(); // 清除map THREAD_LOCAL.set(null); // 线程中ThreadLocalMap remove THREAD_LOCAL.remove(); &#125; private static void init() &#123; THREAD_LOCAL.set(Maps.newHashMap()); &#125;]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发工具</category>
      </categories>
      <tags>
        <tag>ThreadLcoal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring中根据Application获取BEAN的工具类]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2Fspring%E4%B8%AD%E6%A0%B9%E6%8D%AEApplication%E8%8E%B7%E5%8F%96BEAN%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[背景 在最近的开发工作中，用到了策略模式（之前也写过关于策略模式这个设计模式的学习，但是之前那个不是在spring框架中），这时候策略中的context或者factory就要去动态的根据调用的策略类型不同去拿到对应的bean对象，这里去了解了一个通过application context拿取bean的工具类，这里记录一下。 话不多说，直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@Component@Slf4jpublic class ApplicationContextBeanUtil implements ApplicationContextAware &#123; private static ApplicationContext applicationContext; /** * 利用aware注入application * @param applicationContext * @throws BeansException */ @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; // 注入application ApplicationContextBeanUtil.applicationContext = applicationContext; &#125; private static ApplicationContext getApplicationContext() &#123; return applicationContext; &#125; /** * 通过name获取bean * @param name * @return */ public static Object getBean(String name) &#123; return getApplicationContext().getBean(name); &#125; /** * 通过class获取bean * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; T getBean(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(clazz); &#125; /** * 通过name和class获取bean * @param name * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; T getBean(String name, Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBean(name, clazz); &#125; /** * 根据clazz类型获取spring容器中的对象 * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; clazz) &#123; return getApplicationContext().getBeansOfType(clazz); &#125; /** * 根据注解类从容器中获取对象 * @param clazz * @param &lt;T&gt; * @return */ public static &lt;T&gt; Map&lt;String, Object&gt; getBeansOfAnnotation(Class&lt;? extends Annotation&gt; clazz) &#123; return getApplicationContext().getBeansWithAnnotation(clazz); &#125;&#125; 这是通过实现ApplicationContextAware接口去实现注入application的，这里应该注意几点： application应该是静态的。这个Util类应该是在别的类中直接调用获取bean的静态方法，所以注入的applicationContext应该都是该类的静态变量。 要用注解或者在xml文件中将这个Util配置成bean。（这里用的spring boot，就直接配置的扫描）。 在其中提供了一些获取bean的方法。 这里去记录下，方便在之后的工作中遇到了之后去直接使用]]></content>
      <categories>
        <category>spring</category>
        <category>框架应用</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8中list转map方法总结]]></title>
    <url>%2Fblog%2F2018%2F08%2F12%2FJava8%E4%B8%ADlist%E8%BD%ACmap%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景 在最近的工作开发之中，慢慢习惯了很多Java8中的Stream的用法，很方便而且也可以并行的去执行这个流，这边去写一下昨天遇到的一个list转map的场景。 list转map在Java8中stream的应用常用方式1.利用Collectors.toMap方法进行转换123public Map&lt;Long, String&gt; getIdNameMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getId, Account::getUsername));&#125; 其中第一个参数就是可以，第二个参数就是value的值。 2.收集对象实体本身 在开发过程中我们也需要有时候对自己的list中的实体按照其中的一个字段进行分组（比如 id -&gt;List），这时候要设置map的value值是实体本身。123public Map&lt;Long, Account&gt; getIdAccountMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getId, account -&gt; account));&#125; account -&gt; account是一个返回本身的lambda表达式，其实还可以使用Function接口中的一个默认方法 Function.identity()，这个方法返回自身对象，更加简洁 重复key的情况。 在list转为map时，作为key的值有可能重复，这时候流的处理会抛出个异常：Java.lang.IllegalStateException:Duplicate key。这时候就要在toMap方法中指定当key冲突时key的选择。(这里是选择第二个key覆盖第一个key)123public Map&lt;String, Account&gt; getNameAccountMap(List&lt;Account&gt; accounts) &#123; return accounts.stream().collect(Collectors.toMap(Account::getUsername, Function.identity(), (key1, key2) -&gt; key2));&#125; 用groupingBy 或者 partitioningBy进行分组 根据一个字段或者属性分组也可以直接用groupingBy方法，很方便。 12345678Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(&quot;Age &quot; + persons.getKey() + &quot; = &quot; + persons.getValue().size());&#125; partitioningBy可以理解为特殊的groupingBy，key值为true和false，当然此时方法中的参数为一个判断语句（用于判断的函数式接口） 12345Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println(&quot;Children number: &quot; + children.get(true).size());System.out.println(&quot;Adult number: &quot; + children.get(false).size()); 关于stream使用的好文推荐： 这里去看了ibm的一篇关于stream的文章，get到了不少stream还没遇到过的用法。老铁们可以去学习一下。[https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/ ]]]></content>
      <categories>
        <category>Java语法</category>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——CopyOnWrite容器]]></title>
    <url>%2Fblog%2F2018%2F08%2F04%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94CopyOnWrite%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[前言 Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。 什么是CopyOnWrite容器从字面意思上看是写时复制的容器。通俗理解就是我们往一个容器中添加元素时，不直接往容器中添加，而是先将容器copy，复制出一个新的容器，然后新的容器里添加元素，添加完新的元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，但不需要加锁，因为当前在读的容器中不会添加新的元素，运用一种读写分离容器的思想。 copyOnWriteArrayList实现原理来看几个方法（1）add (E e)这里是要加锁的，因为在add的时候是要Arrays.copyOf出一个容器副本的，如果多线程访问会造成copy多个容器副本出来。可以看到是在copy完成添加元素之后去将引用指向这个新的数组。1234567891011121314151617181920/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; （2）get(int index)读的时候并没有加锁，如果读的时候有线程同时去添加元素，还是会读到之前的旧的容器，所以并不用加速，但要求对读的数据一致性没那么高。123456789/** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; return get(getArray(), index);&#125; 应用场景 copyOnWrite并发容器用于读多写少的并发场景。比如白名单、黑名单、商品类目等。比如有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单中，黑名单每晚会更新一次。当用户搜索时，会检查关键字在不在黑名单中，如果在，则提示不能搜索。 另外迭代操作远远大于修改操作时，才应该使用“写入时复制”容器。这个准则很好的描述了许多事件通知系统：在分发通知时需要迭代已注册监听器链表，并调用每个监听器，在大多数情况下，注册和注销事件监听器的操作远少于接受事件通知的操作。 copyOnWriteArrayList用于替代同步list，在某些情况下它提供了更好的并发性能，并且能在迭代期间不需要对容器进行加锁或者复制。 实现一个copyOnWriteMap容器 简单根据“写入时复制”的思想实现一个map容器，并做简单测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package collection;import java.util.AbstractMap;import java.util.HashMap;import java.util.Map;import java.util.Set;/** * 简单根据CopyOnWrite容器的思想去实现一个map 只实现了get put putAll方法 且一些临界异常条件没有去处理 * * @author 夸克 * @create 2018/7/8 15:58 */public class CopyOnWriteMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt; implements Cloneable &#123; private volatile Map&lt;K, V&gt; internalMap; public CopyOnWriteMap() &#123; internalMap = new HashMap&lt;&gt;(); &#125; /** * 此方法未实现 */ @Override public Set&lt;Entry&lt;K, V&gt;&gt; entrySet() &#123; return null; &#125; @Override public V get(Object key) &#123; // 读时不加锁 return internalMap.get(key); &#125; @Override public V put(K key, V value) &#123; // 写时复制加锁 synchronized (this) &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;K, V&gt;(internalMap); V val = newMap.put(key, value); internalMap = newMap; return val; &#125; &#125; @Override public void putAll(Map&lt;? extends K, ? extends V&gt; data) &#123; synchronized (this) &#123; Map&lt;K, V&gt; newMap = new HashMap&lt;&gt;(internalMap); newMap.putAll(data); internalMap = newMap; &#125; &#125; public static void main(String[] args) &#123; CopyOnWriteMap&lt;Integer, Integer&gt; copyOnWriteMap = new CopyOnWriteMap(); // 初始化数据 Map&lt;Integer, Integer&gt; map = new HashMap(); for (int i = 0; i &lt; 10; i++) &#123; map.put(i, i); &#125; // 读五次线程 for (int i = 0; i &lt; 5; i++) &#123; Thread read = new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; // 方便写线程写入数据 如果不加sleep 是读不到数据的，因为是在新复制的容器中写。 // 测试copyOnWrite思想 Thread.sleep(500); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(copyOnWriteMap.get(5)); &#125; &#125;); read.start(); &#125; // 写线程 Thread write = new Thread(new Runnable() &#123; @Override public void run() &#123; map.forEach((k, v) -&gt; &#123; copyOnWriteMap.put(k, v); &#125;); &#125; &#125;); write.start(); &#125;&#125; 代码地址https://github.com/zhanglijun1217/juc 缺点 显然，每次修改容器的时候都会复制底层数组，这回造成一定的内存开销，特别是当容器的规模很大的时候，可能有将内存撑爆的可能性存在。这时候可能要考虑别的容器。另外上边也提到了这种复制一份新的容器延迟的做法会有数据一致性的问题，如果你对写入的数据读出来实时性很高，那么久不要去选择copyOnWrite容器。 其他文章 copyOnWriteArrayList于同步集合工具容器性能比较：性能比较 简单使用：简单使用 引用说明 1.https://www.cnblogs.com/dolphin0520/p/3938914.html2.《java并发编程实战》]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发工具</category>
      </categories>
      <tags>
        <tag>copyOnWrite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程——线程基础（一）]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[线程是Java学习过程中比较难理解的一part，所以要好好打下基础，之后也会对juc包等其他并发编知识去做一个具体的原理性的学习。 一些概念一、并发与并行 并发：同一个时间间隔内做很多件事情；并行：同一个时刻同时做多件事情。 其实对于这句话可以这样理解：并发是两个任务可以在重叠的时间段内启动、运行和完成。并行是任务在同一时间运行，例如，在多核处理器上，并发是独立执行过程的组合，而并行是同时执行的。并发更像是操作系统用线程模型抽象之后站在线程的角度上看到的任务的”同时“执行。 二、临界区 表示一种公有区域或者公有数据，但是每一次只有一个线程使用，其他线程想使用必须等待。进程在访问资源的时候必须经过这些步骤：【进程】–&gt;【进入区（申请资源）】–&gt;【临界区】–&gt;【退出区（释放资源）】 在进入区中资源如果被占用访问，其他进入阻塞队列等待。 阻塞：一个线程占用了临界区资源，其他需要这个资源的线程在临界区中等待，导致这些线程挂起。 非阻塞：其他线程可以同时进入临界区，但保证公有数据不被改坏。 三、锁 死锁（DeadLock）:线程之间互相等待释放资源 饥饿锁（strarvation）:某一个线程或多个线程无法获取资源，导致一直无法执行 活锁（liveLock）:可以想象为电梯遇到人，同时都往一个方向去给对方让出资源，是个动态的问题 四、并发级别 阻塞状态级别 非阻塞状态级别（这里面还分为三种）(1) 无障碍。一种最弱的非阻塞调度，自由进出临界区。无竞争时要求有限步骤内完成操作；无竞争时直接进行回滚数据。(2) 无锁。保证只有一个线程可以胜出访问临界资源。比如乐观锁（CAS）(3) 无等待的，并发中最高级别，是无锁的，要求所有的线程都在有限步内完成，并且无饥饿的。比如：读线程和写线程，所有线程都是无等待的。比如CopyOnWriteArrayList写时写副本数据，读时共享读，线程之间是无等待的。 五、并行的两个定律 加速比：优化前系统耗时/优化后系统耗时。 说明增加CPU个数不一定增加加速比。 古斯塔夫森定律：只要有足够的并行化，那么加速比和CPU个数成正比 六、线程相关知识线程和进程 进程是分配资源的基本单位，线程是CPU调度的基本单位。进程之间的资源是互相独立不可共享的，但是线程之间是可以共享父线程或者进程的资源的。进程之间切换要比线程之间切换消耗资源代价多很多。 线程的状态 新建状态（NEW）：新创建了一个线程对象 可运行状态（RUNNABLE）：线程对象创建之后，其他线程（比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu的使用权。 运行（running）：可运行状态的线程获得了cpu时间片，执行程序代码。 阻塞（block）：阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行（runnable）状态，才有机会再次获得cpu timeslice转到运行（running）状态。其中阻塞的状态分三种：（1）等待阻塞：运行（running）的线程执行o.wait()方法，JVM会把线程放入到等待队列（waitting queue）中。（2）同步阻塞：运行（running）的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池（lock pool）中。（3）其他阻塞：运行（running）的线程执行Thread.Sleep(long ms)或者join方法，或者发出了IO请求，JVM会把该线程置为阻塞状态。当sleep状态超时、join()等待线程终止或者超时、或者IO处理完毕之后，线程重新转入可运行（runnable）状态。 死亡（dead）：线程run()、main()方法执行结束，或者因一场退出了run()方法，则该线程结束生命周期，死亡的线程不可再次复生。 线程状态扭转的图： 可以看到：（1）当调用new Threa()方法之后，线程就会处于新建状态。（2）调用start()方法之后，线程会进入runnable状态，当操作系统选中之后给当前线程分配了时间片线程进入running状态。（3）当run()方法、main()方法结束或者发生异常，线程会进入dead状态。（4）当因为synchronize或者lock同步方法，线程没有获取到锁标识就会进入到锁池（lock pool）中等待；同样当调用o.wait()方法之后线程会进入等待队列中，这时会释放锁或者monitor，直到被其他线程的notify()方法或者notifyAll()方法唤醒。（5）当调用Thread.yield()方法之后，会使线程从running状态转换到runnable状态再去和其他线程一起去竞争时间片资源，所以会出现调用yield()方法之后又重新竞争到了资源变成running状态。（6）当调用了sleep()/join()方法之后，线程并不会释放锁或者monitor，而当sleep时间到了或者调用join()方法的线程执行完毕之后会继续进入running状态。 注意其中线程的一些方法经常在面试中问到的问题： 1.sleep方法和wait方法的区别 （1）sleep是Thread类的方法，wait是Object类的方法（2）调用sleep方法不会释放锁，wait方法会使线程释放当前的锁。（3）wait方法必须别的线程执行notify/notifyAll()方法才能重新获取CPU执行时间。 2.join()方法的本质 join方法是把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如main线程中调用t.join()时候，main线程会获得线程对象t的锁，调用对象的wait方法(等待时间)，直到该对象唤醒main线程，所以意味着main线程调用t.join()时，必须能够拿到线程t对象的锁。注意join()方法也是要捕捉异常的，关于join()方法的比较好的一篇文章：http://uule.iteye.com/blog/1101994 3.yield()方法 yield()方法与sleep()方法类似，只是不能由用户指定暂停多长时间，并且yield()方法只能让同优先级的线程有执行的机会，yield()方法不会释放对象上的锁。 4.wait()和notify()、notifyAll() 这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized中执行使用。synchronized关键字用于保护共享数据，阻止其他线程对共享数据的存取，可以用这三个方法去灵活控制。wait()方法使当前的线程暂停执行并释放对象锁标识，让其他线程可以进入synchronized数据块，当前线程被放入对象等待池中，只有锁标志等待池中线程能获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。notifyAll()方法则从对象等待池中移走所有等待那个对象的线程并放入锁标志等待池中。 wait()、notify()方法是Object类的方法，因为他们必须要标识它们操作线程的锁，而锁对象可能是任何对象，所有这里这两个方法是Object类的方法。 线程创建几种方式继承Thread类 可以继承Thread实现其中的run()方法12345678910111213141516171819202122232425262728293031323334353637public class NewThread2 extends Thread &#123; public NewThread2(String name) &#123; super(name); &#125; @Override public void run() &#123; while (!interrupted()) &#123;// 这里的循环是当不被中断的时候 才执行 System.out.println(getName() + &quot; 线程运行&quot;); &#125; &#125; public static void main(String[] args) &#123; NewThread2 t1 = new NewThread2(&quot;first thread&quot;); NewThread2 t2 = new NewThread2(&quot;second thread&quot;); t1.setDaemon(true);// 后台（守护）线程会随着主线程结束也结束 t2.setDaemon(true); t1.start(); t2.start(); // 中断不用stop()方法 已经过时 t1.interrupt(); t2.interrupt();// try &#123; // 让主线程sleep两秒 Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 实现Runnable接口其实看到Thread类也是实现了Runnable接口的。1234567891011121314151617181920212223242526272829303132333435363738394041424344package newthread;/** * created by zlj on 2018/5/31 * Runnable接口 创建线程 */public class NewThread implements Runnable &#123; @Override public synchronized void run() &#123; while (true) &#123; try &#123; // Thread.sleep(1000);// 调用超时等待使得线程进入阻塞状态 到达时间后线程到达就绪状态 wait();// 线程通讯必须在同步代码块中 否则会报错IllegalMonitorStateException &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;自定义线程执行...&quot;); &#125; &#125; public static void main(String[] args) &#123; NewThread newThread = new NewThread(); // 线程初始化 Thread thread = new Thread(newThread);// 构造函数是runnable接口参数 thread.start();// 调用start方法使得线程进入就绪状态 while (true) &#123; synchronized (newThread) &#123;// 这里同步代码块中监视的是同步的对象 对应上边wait方法获取的是this对象 System.out.println(&quot;主线程执行...&quot;);// try &#123;// Thread.sleep(100);// &#125; catch (InterruptedException e) &#123;// e.printStackTrace();// &#125; newThread.notifyAll();// notify方法必须在同步监视器中 否则会报错 &#125; &#125; &#125;&#125; 实现Callable接口（线程可以有返回值和抛出异常）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package newthread;import java.util.concurrent.Callable;import java.util.concurrent.FutureTask;/** * created by zlj on 2018/5/31 * 带有返回值 和 抛出异常 的线程创建 */public class NewThread4 implements Callable&lt;Integer&gt; &#123; // 实现call方法 // callable接口 和 runnable接口 比较：（1）callable接口可以传入泛型有返回值 （2）可以抛出异常 @Override public Integer call() throws Exception &#123; System.out.println(&quot;正在紧张的计算&quot;); // sleep 模拟计算过程 Thread.sleep(3000); return 1; &#125; public static void main(String[] args) &#123; NewThread4 t = new NewThread4(); /* * 对线程任务的封装 */ // 主线程可以先去做点别的 System.out.println(&quot;先去做点别的&quot;); // 首先用FutureTask&lt;T&gt; 对 call 封装成任务 FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(t); // 再根据构造函数去封装成Thread对象 传入FutureTask类型的task Thread thread = new Thread(task); thread.start(); // 拿到线程的结果 try &#123; System.out.println(&quot;计算的结果是&quot; + task.get()); // 这里注意TaskFuture的get()方法是等上边线程结束之后去进行计算结果的。也是一个闭锁操作 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程池实现1234567891011121314151617181920212223242526272829303132package newthread;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * created by zlj on 2018/5/31 * 线程池创建线程 */public class NewThread6 &#123; public static void main(String[] args) &#123; // 创建十个定长的线程池 ExecutorService threadPool = Executors.newFixedThreadPool(10); // 提交一百个 线程执行的任务 for (int i=0; i&lt;100; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;); &#125; // 线程池的停止销毁 否则程序一直会运行 threadPool.shutdown(); // 注意shutdownNow方法和shutdown方法的区别 threadPool.shutdownNow(); &#125;&#125; Executors中提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。（1）public static ExecutorService newFixedThreadpPool(int nThreads) // 创建国定数目线程的线程池。（2）public static ExecutorService newCachedThreadPool() // 创建一个可缓存的线程池，调用execute将重用以前构造的线程（如果线程可用）。如果线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有60秒钟未被使用的线程。（3）public static ExecutorService newSingleThreadExecutor（） // 创建一个单线程化的Executor（4）public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) // 创建一个支持定时及周期性的任务执行线程池，多数情况可以用来替代Timer类。但是其实在阿里的代码检查工具中，是不建议去使用这个工具类去调用线程池的，建议去手动的写自定义的线程池。 线程中的其他常见方法 方法 说明 setPriority(int priority) 设置线程的优先级 setDaemon(boolean on) 设置是否为后台线程 interrupt() 中断线程 isAlive() 测试线程是否处于活动状态 守护线程和用户线程的区别：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在main线程中创建了一个守护线程，当main方法允许完毕之后，守护线程也会随着消亡，而用户线程则不依赖会一直运行到完毕为止，在JVM中像垃圾回收线程就是守护线程。但是要注意，设置守护线程要在thread.start()方法之前，否则会报IllegalThreadStateException异常。不应该所有的线程都可以分配给Deamon线程来进行服务，比如读写操作或计算逻辑，因为在Deamon Thread没来得及进行操作时，虚拟机可能已经退出了。 停止线程的方法 使用退出标志，使线程正常退出。 使用stop方法终止线程（已过时不推荐） while判断 + interrupt方法终止线程。其中interrupt方法不会终止正在运行的线程，所以要加入一个判断去完成线程的优雅退出。 一些面试题 线程和进程有什么区别？答：一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。 Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?答：sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。 线程的sleep()方法和yield()方法有什么区别？答：① sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；② 线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态；③ sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常；④ sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。 请说出与线程同步以及线程调度相关的方法。wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常；notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关；notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 先写到这关于线程的知识总结还有很多，后边关于并发编程还要更深入的理解，这里先上一张知识总结图吧。]]></content>
      <categories>
        <category>并发编程</category>
        <category>并发基础</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式——策略模式]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式 定义一系列的算法，把每一个算法封装起来，并且使它们可以相互替换。这个模式中使得各个算法可以独立于使用它的客户而变化。 策略模式的构成：1.抽象策略角色：策略类，通常由一个接口或者抽象类实现。2.具体策略角色：包装了相关的算法和行为，实现策略接口或继承抽象类。3.环境角色：context，运行时持有一个策略类的引用，最终给客户端调用。对应的uml图片为： 策略模式让算法独立于使用它的客户而独立变化。策略模式重点是封装不同的算法和行为，不同的场景下可以相互替换。策略模式是开闭原则的体现，开闭原则讲的是一个软件实体应该对拓展开放对修改关闭。因为策略模式在加入新的策略时，不会影响其他类的修改，增加了拓展性，也就是对拓展是开放的；对于调用场景来说，只依赖于抽象，而不依赖于具体实现，所以对修改是关闭的。 策略模式的优点和缺点优点：（1）调用策略中的方法在context中，没有和各个策略的实现耦合在一起，各个实现策略的不同子类可以去拓展、修改和切换。（2）避免写很多if else代码，提高了可观性。同时可以结合抽象类（策略类）去使用，Java支持很好。缺点：（1）客户端调用时必须知道所有的策略类，并且感知到要调用哪一种策略实现。（2）一旦抽象，必然会对一些特殊场景难以处理。并且这里去加入了很多的策略实现类，也有Context类的加入，增加了开销。 代码示例比如现在支付方式有四种，这其中每一种方式都对应着不同的最后费用。这样可以应用策略模式。 Strategy.java12345678910111213package design_pattern.strategy_pattern.intf;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;/** * 抽象策略角色Strategy接口 * @author 夸克 * @create 2018/7/23 17:56 */public interface Strategy &#123; // 定义计算recharge的方法 Double calRecharge(Double charge);&#125; 2.StrategyContext.java123456789101112131415161718192021222324package design_pattern.strategy_pattern.context;import design_pattern.strategy_pattern.factory.StrategyFactory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * 策略模式中的环境角色 context * @author 夸克 * @create 2018/7/24 14:57 */public class Context &#123; private Strategy strategy; public Double calRecharge(Double charge, Integer type) &#123; // 利用一个工厂去生成对应的策略 strategy = StrategyFactory.getInstance().creator(ReChargeTypeEnum.from(type)); if (strategy == null) &#123; throw new RuntimeException(&quot;策略生成错误&quot;); &#125; return strategy.calRecharge(charge); &#125;&#125; 3.策略工厂，返回对应的策略12345678910111213141516171819202122232425262728293031323334353637383940package design_pattern.strategy_pattern.factory;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;import design_pattern.strategy_pattern.strategy.BusiAcctStrategy;import design_pattern.strategy_pattern.strategy.CardStrategy;import design_pattern.strategy_pattern.strategy.EBankStrategy;import design_pattern.strategy_pattern.strategy.MobileStrategy;import java.util.HashMap;import java.util.Map;/** * 策略工厂 负责Strategy实例的创建 根据传入的type实现创建不同的策略 * @author 夸克 * @create 2018/7/24 15:01 */public class StrategyFactory &#123; private static StrategyFactory factory = new StrategyFactory(); private static Map&lt;ReChargeTypeEnum, Strategy&gt; map = new HashMap&lt;&gt;(); static &#123; map.put(ReChargeTypeEnum.E_BANK, new EBankStrategy()); map.put(ReChargeTypeEnum.BUSI_ACCOUNTS, new BusiAcctStrategy()); map.put(ReChargeTypeEnum.MOBILE, new MobileStrategy()); map.put(ReChargeTypeEnum.CARD_RECHARGE, new CardStrategy()); &#125; /** * getInstance方法进行初始化 * @return */ public static StrategyFactory getInstance() &#123; return factory; &#125; public Strategy creator(ReChargeTypeEnum type) &#123; return map.get(type); &#125;&#125; 四种策略的实现：12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:53 */public class BusiAcctStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.9; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:57 */public class CardStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge + charge * 0.01; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:52 */public class EBankStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge * 0.85; &#125;&#125; 12345678910111213141516package design_pattern.strategy_pattern.strategy;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.intf.Strategy;/** * @author 夸克 * @create 2018/7/24 14:54 */public class MobileStrategy implements Strategy &#123; @Override public Double calRecharge(Double charge) &#123; return charge; &#125;&#125; Main.java12345678910111213141516171819202122232425package design_pattern.strategy_pattern.main;import design_pattern.strategy_pattern.constant.ReChargeTypeEnum;import design_pattern.strategy_pattern.context.Context;/** * @author 夸克 * @create 2018/7/26 23:30 */public class StrategyMain &#123; public static void main(String[] args) &#123; Context context = new Context(); /** * 计算四种计算方式 */ Double aDouble = context.calRecharge(100D, ReChargeTypeEnum.E_BANK.getValue()); Double bDouble = context.calRecharge(100D, ReChargeTypeEnum.BUSI_ACCOUNTS.getValue()); Double cDouble = context.calRecharge(100D, ReChargeTypeEnum.MOBILE.getValue()); Double dDouble = context.calRecharge(100D, ReChargeTypeEnum.CARD_RECHARGE.getValue()); System.out.println(aDouble + &quot;\t&quot; + bDouble + &quot;\t&quot; + cDouble + &quot;\t&quot; + dDouble); &#125;&#125; github代码已经上传至我的github：https://github.com/zhanglijun1217/java8/tree/master/src/design_pattern/strategy_pattern 引用https://www.jianshu.com/p/71feb016ac05]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[orika转换bean的字段丢失]]></title>
    <url>%2Fblog%2F2018%2F08%2F02%2Forika%E8%BD%AC%E6%8D%A2bean%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%A2%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[背景 用orika对象转换工具去转换list的时候，发现只去完整转了list的第一条数据，但是后边的数据都没有将字段全部映射上去。 描述： 1.debug时发现的，源数据list是数据都存在的 转完之后的list数据，发现userName、realName等字段是丢失的。 解决经过排查发现是因为在转换注册的字段中，有个type字段没有对应的注册上去。这里就造成了orika这个转换工具丢失了list中记录字段的数据转换。 这里去记录一下这次碰到的小bug，其实也是粗心导致的。]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>orika</tag>
        <tag>bug</tag>
      </tags>
  </entry>
</search>
